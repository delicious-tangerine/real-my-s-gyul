# 실행 계획 분석
MySQL에서 쿼리 실행 계획을 확인하려면 EXPLAIN 명령을 사용하면 된다.<br>
EXPLAIN EXTENDED나 EXPLAIN PARTITIONS 명령을 이용해 더 상세한 실행 계획을 확인할 수도 있다.<br>
<br>
UPDATE나 INSERT, DELETE 문장에 대해서는 실행 계획을 확인 할 방법이 없다. WHERE 조건절만 같은 SELECT 문장을 만들어서 대략적으로 계획을 확인해 볼 수 있다.

## id 컬럼
id칼럼은 단위 SELECT 쿼리별로 부여되는 식별자 값이다.

## select_type 컬럼
- SIMPLE : UNION이나 서브 쿼리를 사용하지 않는 단순한 SELECT 쿼리, 실행 계획에서 반드시 하나만 존재.
- PRIMARY : UNION이나 서브 쿼리가 포함된 SELECT 쿼리의 실행 계획에서 가장 바깥쪽에 있는 단위 쿼리.
- UNION : UNION으로 결합 하는 단위 SELECT 쿼리 가운데 첫 번째를 제외한 두 번째 이후 단위 SELECT 쿼리들은 UNION으로 표시.
- UNION RESULT : UNION 결과를 담아두는 테이블
- SUBQUERY : FROM 절 이외에서 사용되는 서브 쿼리만을 위미
- DERIVED : 서브 쿼리가 FROM 절에 사용된 경우
    - MySQL은 FROM 절에 사용된 서브 쿼리를 제대로 최적화하지 못할 때가 대부분이다. 파생 테이블에는 인덱스가 없으므로 조인시 성능상 불리하다.

## table 컬럼
테이블 칼럼에 < derived > 또는 < union >과 같이 "<>"로 둘러싸인 이름이 명시 되는 경우가 많은데, 임시 테이블을 의미 한다. <br>
"<>" 안에 표시되는 숫자는 해당 임시 테이블을 파생 시킨 단위 SELECT 쿼리의 id이다.

## type 컬럼
각 테이블의 레코드를 어떤 방식으로 읽었는지를 의미한다. <br>
system, const, eq_rf, ...... , ALL 의 여러 가지 방법이 있다. ALL을 제외한 나머지는 모두 인덱스를 사용하는 접근 방법이다.

## possible_keys
possible_keys는 MySQL 옵티마이저가 최적의 실행 계획을 만들기 위해 후보로 선정했던 접근 방식에서 사용되는 인덱스의 목록이다. (실행 계획을 확인 할 때 그냥 무시 하자... 잘못해서 여기 나온거 사용 하면 안된다.)

## key 컬럼
최종 선택된 실행 계획에서 사용하는 인덱스를 의미 한다. 실행 계획의 type 칼럼이 index_merge가 아닌 경우에는 반드시 테이블 하나당 하나의 인덱스만 이용 할 수 있다. 하지만 index_merge 실행 계획이 사용될 때는 2개 이상의 인덱스가 사용되는데, 이때는 key 칼럼에 여러 개의 인덱스가 ", "로 구분되어 표시된다. <br>
실행계획의 type이 ALL일 때와 같이 인덱스를 사용하지 못하면 Key 칼럼은 NULL로 표시 된다.

## key_len 컬럼
쿼리를 처리하기 위해 다중 칼럼으로 만들어진 인덱스에서 몇 개의 칼럼까지 사용했는지 알려 준다. 더 정확하게는 인덱스의 각 레코드에서 몇 바이트 까지 사용했는지 알려 주는 값이다.

## ref 컬럼
접근 방법이 ref 방식이면 참조 조건으로 어떤 값이 제공됐는지 보여 준다. 만약 상수 값을 지정했다면 ref 칼럼의 값은 const로 표시 되고, 다른 테이블의 칼럼값이면 그 테이블 명과 칼럼 명이 표시 된다.

## rows 컬럼
실행 계획의 효율성 판단을 위해 예측했던 레코드 건수를 보여 준다. 이 값은 각 스토리지 엔진별로 가지고 있는 통계 정보를 참조해 MySQL 옵티마이저가 산출해 낸 예상 값이라서 정확하지는 않다.

## extra 컬럼
쿼리의 실행 계획에서 성능에 관련된 중요한 내용이 Extra 칼럼에 자주 표시된다.
- const row not found : const 접근 방식으로 테이블을 읽었지만 실제로 해당 테이블에 레코드가 1건도 존재하지 않으면...
- Distinct
- Full scan on Null key