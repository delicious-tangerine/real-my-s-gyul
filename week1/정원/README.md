# 1주차 : 아키텍처

## MySQL 아키텍처

### MySQL의 전체 구조
**MySQL 엔진** : 커넥션 핸들러, SQL 인터페이스, SQL 파서, SQL 옵티마이저, 캐시& 버퍼 <br>
- 커넥션 핸들러 : 쿼리 요청 처리
- SQL 옵티마이저 : 쿼리 최적화
- 마치 DBMS의 두뇌에 해당 하는 처리


**스토리지 엔진** : InnoDB, MyISAM, Memory, Federated, etc...
- 실제 데이터를 디스크 스토리지에 저장하거나 디스크 스토리지로부터 데이터를 읽어오는 부분


**핻들러 API** : MySQL 엔진의 쿼리 실행기에서 데이터를 쓰거나 읽어야 할 때 스토리지 엔진으로 요청을 보내는 API

<br>

### MySQL의 스레딩 구조

**포그라운드 스레드(클라이언트 스레드)** : MySQL 서버에 접속된 클라이언트의 수만큼 존재하며, 사용자가 요청하는 쿼리 문장을 처리 하는 것이 임무.
- 클라이언트가 작업을 마치고 커넥션을 종료 하면 스레드 풀로 돌아간다.
- thread_cache_size 파라미터로 스레드풀 크기를 조절 할 수 있다.

**백그라운드 스레드** : InnoDB에서 로그 저장이나 쓰기(write) 역할을 하는 스레드

<br>

### 메모리 할당 및 사용 구조

**글로벌 메모리 영역** : 보통 하나의 메모리 공간만 할당 되며 필요시 2개 이상 할당 가능, 모든 스레드가 공유
- 버퍼 풀, 쿼리 캐시, 로그 버퍼, 테이블 캐시

**로컬 메모리 영역** : 세션 메모리 영역 이라고도 하며 커넥션 버퍼와 정렬 버퍼 등이 있다. 각 클라이언트 스레드 별로 독립적으로 할당 되며 공유 되지 않는다.

### 플러그인 스토리지 엔진 모델
MySQL은 필요한 기능을 플러그인 형태로 개발 하여 사용이 가능 하다. 예를 들어, 전문 검색 엔진을 위한 검색어 파서 같은 것이 있다. <br>
MySQL에서 스토리지 엔진을 사용하는 테이블에 대해 쿼리를 실행 하면 단순히 "데이터 읽기/쓰기" 영역만 차이가 있고 GROUP BY나 ORDER BY등은 스토리지 엔진 영역이 아니라 MySQL엔진의 처리 영역인 **"쿼리 실행기"** 에서 처리된다.

<br>

### 쿼리 실행 구조
**파서** : 사용자 요청으로 들어온 쿼리 문장을 토큰으로 분리해 트리 형태의 구조로 만들어 내는 작업 (문법 오류는 이 과정에서 발견됨) <br>
**전처리기** : 파서 트리를 기반으로 쿼리 문장에 구조적인 문제점이 있는지 확인(객체의 존재 여부나 권한 등을 확인) <br>
**옵티마이저** : 쿼리 문장을 저렴한 비용으로 가장 빠르게 처리할지 결정하는 역할 <br>
**실행엔진** : 핸들러에게 요청을 해 받은 결과를 또 다른 핸들러 요청의 입력으로 연결하는 역할 <br>
**핸들러** :  데이터를 디스크로 저장하고 디스크로부터 읽어 오는 역할 <br>

<br>

### 복제 (Replication)
- 2대 이상의 MySQL 서버가 동일한 데이터를 담도록 실시간으로 동기화하는 기술.
- 일반적으로 INSERT, UPDATE 같은 쿼리를 이용해 데이터를 변경할 수 있는 MySQL 서버와 SELECT쿼리로 데이터를 읽기만 할 수 있는 서버로 나뉜다.

**마스터** : 바이너리 로그가 활성화된 MySQL 서버.
- 데이터 구조나 내용을 변경 하는 경우 바이너리 로그에 기록 한다.
- 슬레이브 서버에서 변경 내역을 요청 하면 바이너리 로그를 넘긴다.

**슬레이브** : 마스터 장비의 정보(IP, 포트, 접속 계정)를 갖고 있는 서버.
- 주로 읽기 전용으로 설정 한다.

**주의사항**
- 슬레이브는 하나의 마스터만 설정 가능
- 슬레이브는 마스터와 동일한 사양이 적합 하다. (오히려 슬레이브가 더 좋아야 원활하게 처리를 할 수 있다.)
- 복제가 불필요한 경우 바이너리 로그 중지(성능에 영향을 많이 끼침)

### 쿼리 캐시
- 쿼리의 결과를 담아두고 같은 요청이 왔을 때 캐시에서 찾아 결과를 내려 준다.
- 실행 할 때마다 결과가 달라지는 스토어드 함수(CURRENT_DATE(), SYSDATE(), RAND())는 캐시 효율을 떨어뜨린다.
- query_cache_limit 파라미터를 통해 캐시 결과 사이즈를 조절 할 수 있다. GROUP BY, DISTINCT, COUNT()와 같은 집합 함수의 결과가 캐시를 사용하기에 적합 하다.

## InnoDB 스토리지 엔진 아키텍처
InnoDB는 MySQL의 스토리지 엔진 가운데 가장 많이 사용되며, 유일하게 레코드 기반의 잠금을 제공 한다. <br>
높은 동시성 처리가 가능하고 또한 안정적이다.

### InnoDB 스토리지 엔진의 특성
**프라이머리 키에 의한 클러스터링** : PK값 순서대로 저장 되며 PK에 의한 레인지 스캔은 상당히 빠르다. <br>
**잠금이 필요 없는 일관된 읽기** : MVCC라는 기술을 이용해 락을 걸지 않고 일긱 작업을 수행 한다. 다른 트랜잭션이 가지고 있는 락을 기다리지 않아도 된다. <br>
**외래 키 지원** : 외래키의 지원은 스토리지 엔진 레벨에서 지원하는 기능이다. <br>
**자동 데드락 감지** : 알아서 ROLLBACK 시킨다. <br>
**자동화된 장애 복구** <br>
**오라클의 아키텍처 적용**

<br>

### InnoDB 버퍼 풀
디스크의 데이터 파일이나 인덱스 정보를 메모리에 캐시해 두는 공간으로 쓰기 작업을 지연시켜 일괄 작업으로 처리할 수 있게 해주는 버퍼 열할도 한다. (디스크 작업 횟수를 줄일 수 있다.) <br>
일반적으로 전체 장착된 물리 메모리의 5~80% 수준에서 버퍼 풀의 메모리 크기를 결정 한다.

### 언두 로그
UPDATE, DELETE 문장으로 데이터를 변경했을 때 변경되기 전의 데이터를 보관 하는곳. (트랜잭션의 롤백 대비용, 롤백 할 때 언두 로그에서 꺼내 롤백 한다.)

### 인서트 버퍼
인덱스를 업데이트 치기 위해 잠시 저장해두는 메모리 공간, 사용자에겐 바로 결과를 돌려 주고 디스크 쓰기는 나중에 한다.

### 리두 로그 및 로그 버퍼
데이터 파일의 변경 작업은 랜덤한 디스크 작업을 일으키기 때문에 디스크를 상당히 바쁘게 만든다. 부하를 줄이기 위해 버퍼를 사용 하지만 버퍼만으로는 안심 할 수 없다. 내용을 순차적으로 디스크에 기록 하라는 로그(리두 로그)를 두어 안정성을 높인다.

### MVCC
잠금을 사용 하지 않는 일관된 읽기. InnoDB는 언두 로그를 이용해 이 기능을 구현 한다. 데이터가 변경 되었을 때 격리 수준이 READ_UNCOMMITED 이면 버퍼 풀이나 데이터 파일로부터 변경되지 않은 데이터를 읽어 반환 한다. READ_COMMITTED나 그 이상이라면 변경되기 이전 내용(언두 로그)을 반환 한다. 트랜잭션이 길어 지면 언두 영역의 데이터가 많아 진다. (잘 조절 하자)

### 잠금 없는 일관된 읽기
격리 수준이 SERIALIZABLE이 아닌 READ-UNCOMMITTED나 READ-COMMITTED 그리고 REPEATABLE-READ 수준의 경우 다른 트랜잭션의 변경 작업과 관계 없이 항상 작믕르 대기하지 않고 바로 실행된다.

### InnoDB vs MyISAM
InnoDB 스토리지 엔진은 MyISAM과 비교할 수준이 아닐 정도로 많은 특징과 기능을 가지고 있으며 안정성 또한 MyISAM에 비할 바가 못 된다.

## Memory 스토리지 엔진
사용자가 명시적으로 MEMORY 테이블을 정의해서 사용할 때도 있지만, MEMORY 테이블은 주로 MySQL 엔진이 쿼리를 처리하는 과정에서 임시로 생성되는 임시 테이블 용도로 자주 사용 된다.

<br>

## MySQL 로그 파일
MySQL은 DBA나 개발자를 위한 진단 도구가 부족한 편이지만 로그 파일을 이용하면 MySQL의 상태나 부하를 일으키는 원인을 찾아서 해결 할 수 있다! <br>

### 에러 로그 파일
conf 파이르이 log_error라는 이름의 파라미터에 정의된 경로에 저장된다.<br>

아래의 것들이 에러로그 파일에 담긴다.
- MySQL이 시작하는 과정과 관련된 정보성 및 에러메세지
- 마지막으로 종료할 때 비정상적으로 종료된 경우 나타나는 InnoDB의 트랜잭션 복구 메시지
- 쿼리 처리 도중에 발생하는 문제에 대한 에러 메시지
- 비정상적으로 종료된 커넥션 메시지

### 제너럴 쿼리 로그 파일
MySQL 서버에서 실행되는 쿼리의 전체 목록 (저장 할지 말지는 파라미터로 설정 가능)

### 슬로우 쿼리 로그
정상적으로 실행이 완료 되고, long_query_time에 정의된 초 보다 많이 걸린 쿼리들의 로그.<br>
서비스 적용되기 전 전체적으로 튜닝하는 경우와 서비스 운영 중에 MySQL 서버의 전체적인 성능 저하를 검사 하는데 주로 쓰임.

### 바이너리 로그와 릴레이 로그
바이너리 로그 파일은 마스터 MySQL 서버에 생성되고 릴레이 로그는 슬레이브 MySQL 서버에 생성 된다.<br>
바이너리 로그와 릴레이 로그 파일의 내용이나 포맷은 동일 하다. 바이너리 로그는 SELECT문 같은 변경이 일어나지 않는 쿼리는 저장 되지 않는다.<br>
바이너리 로그는 까보려면 mysqlbinlog라는 프로그램을 이용 해야 한다.<br>
[사례](https://www.youtube.com/watch?v=SWZcrdmmLEU&t=764s)