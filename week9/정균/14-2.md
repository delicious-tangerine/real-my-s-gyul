# `14.2 물리 모델링`

물리 모델링에서는 논리 모델링을 통해 나온 결과를 RDBMS의 특성에 맞게 변환하는 작업을 수행합니다.

- 논리 모델에서 신경 쓰지 않았던 M:M 관계와 같이 RDBMS에 구현할 수 없는 구조를 해소하는 작업
- 프라이머리 키의 컬럼 순서 선정
- 컬럼의 이름 부여
- 컬럼의 데이터 타입 선정
- 조회 성능을 위한 반정규화

<br> <br>

## `14.2.1 프라이머리 키 선택`

논리 모델링에서 식별자는 최대한 간결하면서도 엔티티의 레코드를 대표할 수 있는 어트리뷰트의 집합으로 선정했습니다. `하지만 논리 모델링에서 선정한 식별자가 항상 물리 모델의 프라이머리 키가 되는 것은 아닙니다.`
또한 논리 모델에서는 식별자를 구성하는 각 속성의 순서가 크게 관심 대상이 아니지만 `물리 모델에서는 프라이머리 키를 구성하는 컬럼의 순서가 매우 중요합니다.`

![스크린샷 2021-08-12 오후 3 44 06](https://user-images.githubusercontent.com/45676906/129150151-579ab850-66de-44e1-8924-4f53b7f29e83.png)

위의 모델을 주면 관계의 제일 마지막에 있는 주문 내역 테이블은 4개의 컬럼으로 프라이머리 키가 구성되어 있습니다. 테이블의 프라이머리 키를 복합 컬럼으로 구성할 때는 너무 많은 컬럼이 프라이머리 키로 참여하지 않게 적절히 끊어줄 필요가 있습니다. 자식 테이블 중에서도 관계를 많이 가지는 중요 테이블에서 부모와의 프라이머리 키 상속을 끊고, 새로운 프라이머리 키를 갖게 해주는 것이 좋습니다. => `인조 키` 부여

```
MyISAM 스토리지 엔진과 같이 프라이머리 키가 클러스터링의 기준이 되지 않는 스토리지 엔진에서는 프라이머리 키를 구성하는 컬럼의 개수가 조금 많아도 큰 악영향은 없습니다. 하지만 InnoDB 스토리지 엔진과 같이 기본적으로 프라이머리 키에 의해 클러스터링되는 스토리지 엔진에서는 테이블의 레코드 주소 대신 프라이머리 키가 레코드의 주소로 사용됩니다. 그래서 모든 보조 인덱스가 프라이머리 키 값을 데이터 레코드의 포인터로 가지므로 프라이머리 키의 길이가 길어질수록 프라이머리 키 뿐만 아니라 다른 보조 인덱스의 크기도 커진다는 단점이 있습니다.
```

InnoDB의 프라이머리 키는 클러스터링 키로 사용되므로 다른 보조 인덱스의 레인지 스캔보다 훨씬 빠르게 처리됩니다. 테이블을 대표하는 컬럼으로 프라이머리 키를 선정하는 것은 당연하지만 프라이머리 키 후보가 여러 개라면 조회 조건으로 가장 많이 사용되는 것을 프라이머리 키로 선정하는 것이 좋습니다. 

<br> <br>

## `14.2.2 데이터 타입 선정`

물리 모델링에서 컬럼의 데이터 타입은 가능한 한 최소 단위의 타입을 부여해야 합니다. 가끔 `VARCHAR(10)`이나 `VARCHAR(100)` 모두 필요한 만큼의 공간을 사용하는 것인데, 왜 `VARCHAR(100)`을 사용해야 하는가? 라는 질문이 있습니다.(큰 차이 없을 줄 알았는데!)

이것은 `임시테이블`과도 연관이 있는데요. 테이블의 컬럼 `first_name` 이라는 컬럼이 `VARCHAR(512` 라고 가정해보겠습니다. 실제 메모리 테이블에서 first_name 컬럼이 차지하는 공간은 512 * 3(UTF8 기준) 바이트가 될 것입니다. `실제 first_name 컬럼의 값이 1글자이든 2글자이든 관계없이, 테이블에 정의된 크기만큼 메모리 테이블에서 공간을 차지한다는 특징이 있습니다.`
이러한 임시 테이블의 저장 방식 때문에 SELECT 하는 컬럼은 최소화하고(특히 BLOB 이나 TEXT 컬럼은 배제하는 것이 좋음) 컬럼의 데이터 타입 선정도 가능한 작게 해주는 것이 좋습니다.

`테이블의 레코드 건수가 많지 않다면 어떤 컬럼이 프라이머리 키로 선정되고, 각 컬럼의 타입이 어떻게 설정되든 큰 차이는 없습니다. 하지만 테이블의 레코드 건수가 많아지면 데이터 타입을 한 바이라도 크게 설정하면 많은 차이를 만들어 낼 수 있습니다.`

<br> <br>

### `데이터의 타입`

어떤 데이터를 관리하기 위해 사용할 수 있는 데이터 타입은 여러 가지가 있을 수 있습니다. 만약 각 데이터 타입별로 차지하는 공간이나 성격을 잘 모른다면 저장하려는 데이터 성격별로 그대로 타입을 선정하는 것이 가장 좋습니다.
ex) 숫자는 숫자타입, 날짜는 문자가 아니라 날짜 타입

<br> <br>

### `컬럼의 길이`

컬럼이 어떤 특성이 가지냐에 따라서 컬럼의 길이를 결정해야 합니다. 어쩌면 당연한 말?

<br> <br>

### `NULL과 NOT NULL`

- InnoDB 스트리지 엔진
  - InnoDB 테이블에서는 컬럼이 NULL 이면 고정된 타입, 가변 타입(VARCHAR 등) 모두 NULL이 저장되는 컬럼은 전혀 디스크 공간을 사용하지 않습니다. 즉, InnoDB는 NULL을 저장함으로써 실제 디스크의 공간 절약을 할 수 있습니다.
  
<br>

NULL이 저장될 수 있는 컬럼에 대해 IN 형태의 조건을 사용하면 MySQL은 상상하지 못했던 이상한 비교 작업을 내부적으로 하게 됩니다. 
하지만 NULL과 NOT NULL은 디스크 공간 절약의 문제가 아니라 옵티마이저가 얼마나 쿼리를 더 최적화할 수 있게 환경을 만들어줄 것이느냐의 관점에서 고려 해야 합니다.

<br> <br>

## `14.2.3 반정규화`

모델의 정규화는 최대한 중복되는 컬럼을 제거하므로 INSERT와 UPDATE와 같은 데이터 변경 작업에 최적화된 모델을 만들어냅니다. 하지만 모델을 정규화할수록 SELECT 쿼리에서 필요한 테이블의 수 뿐만 아니라 GROUP BY 쿼리 자체의 개수도 증가합니다. (JOIN이 늘어남!)

현재 MySQL 5.x 버전은 조인이 상당히 최적화돼 있어서 크게 문제되지 않지만 많은 레코드를 GROUP BY 하는 쿼리는 실시간으로 실행하기에는 부담스러울 수도 있습니다. `GROUP BY나 COUNT(*)와 같이 많은 레코드를 대상으로 하는 작업을 빠르게 조회하기 위해 미리 건수를 집계해서 별도의 테이블이나 컬럼을 저장해두는 것을 반정규화` 라고 합니다.(오.. 항상 고민했던 것인데)

반정규화에서 주의해야 할 것은 어떻게 반정규화된 컬럼이나 테이블을 유지할 것인가입니다. 일반적으로 반정규화된 컬럼은 실시간으로 업데이트하는 방식으로 유지하는데, 이는 INSERT, UPDATE, DELETE 작업을 할 때 또 다른 쿼리를 필요로 하므로 변경 작업의 부하가 커지고 잠금의 경합도 많이 일으킵니다. 
반정규화된 컬럼의 값을 유지하려면 최대한 모아서 배치 형태로 실행하거나 백그라운드 작업으로 처리하는 것이 좋습니다.

반정규화의 종류와 방법을 살펴보겠습니다. 

<br> 

### `컬럼 복사`

원본 컬럼의 값을 변경하지 않고 그대로 다른 테이블로 복사해 두는 형태의 반정규화는 조인을 없애거나 GROUP BY나 ORDER BY 등을 인덱스로 처리할 수 있도록 유도하기 위해서입니다.
`그런데 조인을 줄이기 위해 반정규화를 하는 것은 그다지 효율적이지 않습니다.` 만약 반정규화해서 복사해 온 컬럼이 자주 변경된다면 비효올적인 작업이 될 것입니다. 하지만 복사한 컬럼을 이용해 GROUP BY나 ORDER BY 처리를 인덱스로 할 수 있다면 성능상 상당히 도움될 수 있습니다.

<br>

### `조인을 제거하기 위한 용도`

게시물 테이블을 조회할 때 회원 테이블과 조인하지 않기 위해 회원의 이름을 게시물 테이블에 복사해두는 형태입니다. 하지만 최근에는 조인의 횟수를 줄이기 위해 컬럼을 복사해두는 반정규화는 거의 사용하지 않습니다.
만약 회원명 컬럼이 자주 변경된다면 효율성은 더 떨어지고, 데이터 정합성에 문제가 생길 소지만 더 늘어나는 꼴이 될 수 있기 때문입니다.

