# `스키마 조작 (DDL)`

- 데이터베이스의 구조 및 정의를 생성하거나 변경하는 쿼리를 DDL (DB나 테이블 등을 생성하거나 변경하는 대부분의 명령은 DDL)

- 데이터베이스에 입력된 레코드를 조회하거나 수정하거나 삭제하는 것은 DML

<br>

## `데이터베이스 목록`

```sql
SHOW DATABASES;
```

<br>

## `데이터베이스 선택`

```sql
USE employees;
```

<br> <br>

## `테이블 구조 조회`

```sql
SHOW CREATE TABLE employees;
```

위의 명령을 통해서 `인덱스`, `외래키` 정보를 동시에 볼 수 있어서 테이블 구조를 파악할 때 유용하게 사용될 수 있음

<br>

## `테이블 구조 변경`

- 테이블 구조를 변경하려면 `ALTER TABLE` 명령을 사용 

- ALTER TABLE 명령은 테이블 자체의 속성을 변경할 수 있을 뿐더러 인덱스의 추가 삭제나 컬럼을 추가/삭제하는 용도로도 사용된다. 

```sql
ALTER TABLE employees CHARACTER SET `euckr`;
ALTER TABLE employees ENGINE=myisam;
```

- 테이블의 문자집합을 변경하는 첫 번째 명령은 테이블 내에 이미 존재하는 컬럼의 문자집합을 변경하는 것이 아니고 앞으로 추가될 기본 문자집합만 변경하는 명령

- 테이블의 스토리지 엔진을 변경하는 명령어 

- 내부적인 테이블의 저장소를 변경하는 것이라서 항상 테이블의 모든 레코드를 복사하는 작업이 필요함

- 기존 엔진과 같은 엔진을 사용해도 테이블의 데이터를 복사하는 작업은 발생하니까 주의해서 사용해야 한다. 

<br> <br>

## `RENAME TABLE`

- P528 예시

```sql
RENAME TABLE emp_stat TO backup_emp_start, temp_emp_stat TO emp_stat;
```

- 위의 에제에서 쿼리는 하나의 RENAME TABLE 명령으로 두 테이블의 이름 변경 작업을 처리한 것이다. 

- MySQL `RENAME TABLE` 명령을 실행할 때 네임 락이라는 잠금을 사용해서 RENAME TABLE 명령에 있는 모든 테이블에 대해 한 번에 잠금을 걸고 작업을 진행한다. 

<br> <br>

## `테이블의 DB 변경`

- RENAME TABLE 명령은 순순하게 테이블의 이름을 변경하는 것뿐만 아니라 테이블을 A DB에서 B DB로 옮길 때도 유용하게 사용됨 

```sql
RENAME TABLE db1.employees TO db2.employees;
```

위의 쿼리는 테이브르이 이름은 그대로지만 DB를 바꿀 때는 db1 디렉터리에 있는 employees 테이블의 데이터 파일을 db2 디렉터리로 이동시킴

<br> <br>

## `테이블 상태 조회`

```sql
SHOW TABLE status LIKE `employees`\G 
```

위의 명령어를 통해서 테이블이 어떤 스토리지 엔진을 사용하는지, 데이터 파이르이 포맷을 뭘 사용하고 있는지 등을 조회할 수 있다. 

<br> <br>

## `테이블 삭제`

- 레코드 건수가 많은 테이블을 삭제하는 작업은 상당히 부하가 큰 작업에 속한다. 

- 테이블이 크다면 서비스 도중에 삭제(DROP TABLE)을 안하는 것이 좋다. 

- `MySQL에서 테이블을 삭제하려면 반드시 LOCK_open 이라는 잠금을 획득해야 함` => MySQL 5.0, 5.1에서는 LOCK_open은 `글로벌 잠금`이라는 것

- 예를들어 A 테이블에 LOCK_open 잠금이 걸려도, B, C 테이블도 열거나 닫는 작업을 블러킹 걸려서 작업을 못하게 되는 문제가 생김

- 즉, A 테이블의 DROP TABLE 명령이 완료될 때까지 MySQL 서버는 다른 커넥션의 쿼리는 전혀 처리하지 못하게 됨

<br> <br>

## `컬럼 변경`

### 컬럼 추가

- MySQL에서 컬럼을 추가하는 작업은 항상 테이블의 데이터를 새로운 테이블로 복사하는 형태로 처리한다. 따라서 레코드 건수가 많아질 수록 컬럼 추가 작업이 느려짐

<br>

### 컬럼 삭제

- 컬럼을 삭제하는 작업도 테이블의 데이터를 새로운 테이블로 복사하면서 컬럼을 제거하는 형태로 처리하기 때문에 레코드 건수에 따라 처리 시간이 달라진다. 

<br>

### 컬럼 이름이나 타입 변경

- 컬럼의 이름만을 변경하는 작업은 실제 테이블의 데이터는 변경하지 않고 테이블의 구조 정보만 변경하는 작업이다. 따라서 테이블 레코드 건수와 관계없이 빠르게 처리 됨

<br>

### 컬럼명 이외의 타입이나 NULL 여부를 변경하는 경우

- ENUM이나 SET과 같은 타입에 새로운 아이템이 추가될 때는 데이터를 복사하지 않고 테이블의 메타 정보만 변경하기에 빠르게 처리 됨

- 타입 변환이나 NULL 여부 변경은 테이블의 데이터를 복사하면서 구조를 변경하는 형태로 처리하기 때문에 레코드의 건수에 따라 상당히 시간이 걸리는 작업

<br> <br>

## 인덱스 변경

### 인덱스 추가

- MySQL 5.0 이하의 버전에서는 테이블의 모든 레코드를 복사하는 형태로 인덱스를 생성하는 작업이 처리됐다. 

- MySQL 5.1, 5.5 MyISAM 테이블에서 인덱스를 생성하는 작업은 MySQL 5.0과 마찬가지로 임시 테이블로 복사하는 형태로 처리

- `하지만 InnoDB 테이블에 대해서는 MySQL 5.1 InnoDB 플로그인 버전부터 데이터 자체는 그대로 두고, 인덱스만 생성하는 형태로 개선 됐다고 함!`

- 인덱스 알고리즘은 일반적으로 `B-Tree`, `HASH`가 사용됨

<br> <br>

### 인덱스 조회

- `SHOW INDEX FROM` 명령을 이용하면 테이블의 인덱스를 조회할 수 있다. 

- 인덱스의 중요한 정보인 기수성(Cardinality) 정보도 표시 됨 (P540)

<br> <br>

### 인덱스 삭제

- 인덱스 추가와 마찬가지로 InnoDB 테이블은 데이터 자체는 그대로 두고 인덱스만 삭제하기 때문에 5.0 방식 보다 훨씬 빠르게 처리 된다. 

- InnoDB의 프라이머리 키 삭제는 MySQL 5.0에서 처럼 테이블의 모든 레코드를 복사하면서 처리 한다. 

- InnoDB의 프라이머리 키가 클러스터링 키 이기 때문에 피할 수 없는 부분!

<br> <br>

