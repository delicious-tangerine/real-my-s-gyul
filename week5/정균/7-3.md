## `리터럴 표기법`

- SQL 표준에서 문자열은 항상 홑따옴표(')를 사용함

- 하지만 MySQL에서는 아래와 같이 쌍따옴표를 사용해서 문자열을 표기 가능

```sql
SELECT * FROM departments WHERE dept_no='d001';
SELECT * FROM departments WHERE dept_no="d001";
```

<br>

또 다른 예시

```sql
SELECT * FROM departments WHERE dept_no='d''001';
SELECT * FROM departments WHERE dept_no='d"001';
SELECT * FROM departments WHERE dept_no="d'001";
SELECT * FROM departments WHERE dept_no="d""001";
```

- 첫 번째와 두 번째는 SQL 표준 문법

- 세 번째와 네 번째는 MySQL에서만 지원되는 방식

<br>

## `숫자`

문자열 형태로 따옴표를 사용하더라도 비교 대상이 숫자 값이거나 숫자 타입의 컬럼이면 MySQL 서버가 문자열 값을 숫자 값으로 자동 변환해준다. 하지만 이처럼 숫자 값과 문자열 값을 비교할 때는 한 가지 주의해야 할 사항이 있다. 

```sql
SELECT * FROM tab_test WHERE number_column='10001';
SELECT * FROM tab_test WHERE string_column=10001;
```

- 위의 쿼리와 같이 두 비교 대상이 문자열과 숫자 타입으로 다를 때는 자동으로 타입의 변환이 발생

- MySQL은 숫자 타입과 문자열 타입 간의 비교에서 숫자 타입을 우선시하므로 문자열 값을 숫자 값으로 변환한 후 비교를 수행

- 첫 번째 쿼리는 주어진 상수값을 숫자로 변환하는데, 이 때는 상수값 하나만 변환하므로 성능과 관련된 문제가 발생하지 않음

- 두 번째 쿼리는 주어진 상수값이 숫자 값인데 비교되는 컬럼은 문자열 컬럼이다. 이 때 MySQL은 문자열 컬럼을 숫자로 변환해서 비교한다. 즉, string_column 컬럼의 모든 문자열 값을 숫자로 변환해서 비교를 수행해야 하므로 string_column에 인덱스가 있다 하더라도 이를 이용하지 못함

<br> <br>

## `Like 연산자`

- Like 연산자는 와일드카드 문자인 (%, _)가 검색어의 뒤쪽에 있다면 인덱스 레인지 스캔으로 사용할 수 있지만 와일드카드가 검색어의 앞쪽에 있다면 인덱스 레인지 스캔을 사용할 수 없다. 

<br>

## `In 연산자`

- IN은 여러 개의 값에 대해 동등 비교 연산을 수행하는 연산자이다. 여러 개의 값이 비교되지만 범위로 검색하는 것이 아니라 여러 번의 동등 비교로 실행하기 때문에 일반적으로 빠르게 처리된다. 

- MySQL에서 IN 연산자는 사용법에 따라 상당히 비효율적으로 처리될 때도 많다. 

- `IN 연산자의 입력이 상수가 아니라 서브 쿼리인 경우에는 상당히 느려질 수 있다.`

- IN의 인자가 상수로 사용되면 이 상수값이 쿼리의 입력 조건으로 사용하기 때문에 기대했던 대로 적절히 인덱스를 이용해 쿼리를 실행

- 하지만 IN의 입력으로 서브 쿼리를 사용할 때는 서브 쿼리가 먼저 실행되어 그 결과 값이 IN의 상수 값으로 전달되는 것이 아니라, 서브 쿼리의 외부가 먼저 실행되고 IN은 체크 조건으로 사용됨

<br>

## `COUNT()`

- count(*)에서 *는 SELECT 절에 사용될 때처럼 모든 컬럼을 가져오라는 의미가 아니라 그냥 레코드 자체를 의미하는 것

- 실제로 COUNT(*) 라고 해서 레코드의 모든 칼럼을 읽는 형태로 처리하지 않음 (속도 차이도 나지 않음)

```sql
SELECT COUNT(*) FROM tb_table 
```

- 위와 같이 WHERE 조건이 없는 COUNT(*) 쿼리는 MySQL 서버가 실제 레코드 건수를 세어 보지 않아도 바로 결과를 반환할 수 있기 때문에 빠르게 처리됨

- 하지만 큰 테이블에서는 COUNT() 함수를 사용하는 작업은 주의해야 함

- COUNT(*) 쿼리에서 `ORDER BY` 구문이나 `LEFT JOIN`과 같은 레코드 건수를 가져오는 것과는 전혀 무관한 작업을 포함하는 것

<br>

### `주의 사항`

- 일반적으로 컬럼의 값을 SELECT 하는 쿼리보다 COUNT(*) 쿼리가 훨씬 빠르게 실행될 것이라 생각할 때가 많다. 

- 하지만 인덱스를 제대로 사용하도록 튜닝하지 못한 COUNT(*) 쿼리는 페이징해서 데이터를 가져오는 쿼리보다 몇 배 또는 몇십 배 더 느리게 실행될 수도 있다. 

- COUNT(*) 쿼리도 많은 부하를 일으키기 때문에 주의 깊게 작성해야 함