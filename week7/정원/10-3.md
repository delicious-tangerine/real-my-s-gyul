# MySQL 파티션의 종류
레인지 파티션, 리스트 파티션, 해시 파티션, 키 파티션 의 4가지 기본 파티셔닝 기법을 제공 한다. 해시키와 키 파티션에 대해서는 리니어 파티션과 같은 추가적인 기법도 제공한다.

## 레인지 파티션
파티션 키의 연속된 범위로 파티션을 정의하는 방법으로, 가장 일반적으로 사용되는 파티션 방법 중 하나다.

### 레인지 파티션의 용도
주로 다음과 같은 성격을 지닌 테이블에서 레인지 파티션 사용
- 날짜를 기반으로 데이터가 누적되고 년도나 월 또는 일 단위로 분석하고 삭제해야 할 때
- 범위 기반으로 데이터를 여러 파티션에 균등하게 나눌 수 있을 때
- 파티션 키 위주로 검색이 자주 실행될 때

### 레인지 파티션 테이블 생성
```
CREATE TABLE employees (
    id INT NOT NULL,
    first_name VARCHAR(30),
    last_name VARCHAR(30),
    hired DATE NOT NULL DEFAULT '1970-01-01',
    ...
) ENGINE=INNODB
PARTITION BY RANGE ( YEAR(hired) ) (
    PARTITION p0 VALUES LESS THAN (1911) ENGINE=INNODB,
    ...
    PARTITION p3 VALUES LESS THAN MAXVALUE ENGINE=INNODB,
);
```

- VALUES LESS THAN MAXVALUE가 정의되지 않으면 LESS THAN에 만족 하지 않는 값이 들어오면 에러가 발생 한다.
- 각 파티션에 ENGINE을 명시하지 않으면 테이블의 스토리지 엔진이 자동으로 적용된다.

### 레인지 파티션의 분리와 병합
- ALTER 명령어를 통해 단순 파티션의 추가, 삭제가 가능 하다.
- REORGANIZE PARTITION 명령으로 하나의 파티션을 두 개 이상의 파티션으로 분리 할 수 있다.
- REORGANIZE PARTITION 명령으로 파티션을 병합 할 수 있다.

### 레인지 파티션 주의사항
레인지 파티션에서 NULL은 어떤 값보다 작은 값으로 간주된다. 만약 employees 파티션 테이블에 hired 칼럼이 NULL인 레코드가 INSERT 된다면 이 레코드는 입사 일자가 가장 작은 값을 저장하는 파티션으로 저장 된다. <br>
날짜 칼럼에 대해 레인지 파티션을 적용할 경우 YEAR(), TO_DAYS()의 2개의 함수 중 하나를 사용하길 권장.

## 리스트 파티션
레인지 파티션과 많은 부분에서 흡사하게 동작 하지만 레인지 파티션은 파티션 키 값의 연속된 값의 범위로 파티션을 구성할 수 있지만 리스트 파티션은 파티션 키 값 하나하나를 리스트로 나열해야 한다.

### 리스트 파티션의 용도
테이블이 다음과 같은 특성을 지닐 때는 리스트 파티션을 사용하는 것이 좋다.
- 파티션 키 값이 코드 값이나 카테고리와 같이 고정적일 때
- 키 값이 연속되지 않고 정렬 순서와 관계없이 파티션을 해야 할 때
- 파티션 키 값을 기준으로 레코드의 건수가 균일하고, 검색 조건에 파티션 키가 자주 사용될 때

### 리스트 파티션 테이블 생성
```
CREATE TABLE product(
    id INT NOT NULL,
    name VARCHAR(30),
    category_id INT NOT NULL
    ...
)
PARTITION BY LIST ( category_id ) (
    PARTITION pappliance VALUES IN (3),
    PARTITION pcomputer VALUES IN (1, 9),
    PARTITION psports VALUES IN (2, 6, 7),
    PARTITION petc VALUES IN (4, 5, 8, NULL)
);
```

MySQL 5.5 부터는 파티션 타입이 문자열 타입일 때도 리스트 파티션을 사용할 수 있다.

### 리스트 파티션의 분리와 병합
VALUES LESS THAN이 아닌 VALUSE IN을 사용한다는 것 말고는 레인지 파티션의 추가, 삭제, 병합 작업과 모두 같다.

### 리스트 파티션 주의사항
- 명시되지 않은 나머지 값을 저장하는 MAXVALUE 파티션을 정의할 수 없다.
- 레인지 파티션과는 달리 NULL을 저장하는 파티션을 별도로 생성할 수 있다.

## 해시 파티션
해시 파티션은 MySQL에서 정의한 해시 함수에 의해 레코드가 저장될 파티션을 결정하는 방법이다.

### 해시 파티션의 용도
- 레인지 파티션이나 리스트 파티션으로 데이터를 균등하게 나누는 것이 어려울 때
- 테이블의 모든 레코드가 비슷한 사용 빈도를 보이지만 테이블이 너무 커서 파티션을 적용해야 할 때
대표적인 용도로는 회원 테이블을 들 수 있다. 회원 정보는 가입 일자가 오래돼서 사용되지 않는다거나 최신이어서 더 빈번하게 사용되거나 하지 않는다. 즉, 데이터가 특정 칼럼의 값에 영향을 받지 않고, 전체적으로 비슷한 사용 빈도를 보일 때 적합한 파티션 방법이다.

### 해시 파티션의 분리와 병합
해시 파티션의 분리, 병합은 리스트 파티션이나 레인지 파티션과는 달리, 대상 테이블의 모든 파티션에 저장된 레코드를 재분배하는 작업이 필요하다.
- 해시 파티션이 추가 되면 기존의 각 파티션에 저장된 모든 레코드가 재배치돼야 한다.
- 해시 파티션은 특정 파티션의 삭제가 불가능 하다. (해서도 안된다.)
- 해시 파티션은 분할이 불가능 하고 파티션의 개수를 늘리는 것만 가능하다.
- 해시 파티션은 병합 기능을 제공하지 않는다. 단순히 개수를 줄이는 것만 가능 하다.

## 키 파티션
해시 파티션과 사용법과 특성이 거의 같다.

## 리니어 해시 파티션 / 리니어 키 파티션
해시 파티션이나 키 파티션은 새로운 파티션을 추가하거나 파티션을 통합해서 개수를 줄일 때 대상 파티션만이 아니라 테이블전체 파티션에 저장된 레코드의 재분배 작업이 발생 한다.
이러한 단점을 최소화 하기 위해 리니어 해시/키 파티션 알고리즘이 고안된 것이다.

## 리니어 파티션의 추가 및 통합
"Power-of-two" 분배 방식을 사용하기 때문에 파티션의 추가나 통합 시 특정 파티션의 데이터에 대해서만 이동 작업을 하면 된다.

## 서브 파티션
서비스 요건에 따라 기간 단위로 레인지 파티션을 생성하고, 각 레인지 파티션 내에서 다시 지역별로 리스트 서브 파티션을 구성하는 형태의 파티션이 가능 하다. 하지만 MySQL에서는 최대로 사용 가능한 파티션의 개수가 다른 DBMS보다 상당히 제한적이라서 서브 파티션으로 얻을 수 있는 이점은 별로 없다.

## 파티션 테이블의 실행 계획
쿼리의 성능은 테이블에서 얼마나 많은 파티션을 프루닝할 수 있는지가 관건이다. EXPLAIN PARTITIONS 명령어로 실행 계획을 확인 해 볼 수 있다.

```
EXPLAIN PARTITIONS
SELECT * FROM employees
WHERE hired='1995-12-10';
```

## 파티션 기능에 대한 결론
결과상 SELECT 쿼리의 성능에는 그다지 큰 도움을 주지 못했으며, 쓰기 성능에는 어느 정도 도움되는 것으로 보인다. <br>
INSERT, UPDATE, DELETE는 읽기에 비해 상대적으로 비용이 많이 드는 작업이다. 이는 인덱스나 칼럼의 개수가 많아지고 한 레코드의 크기가 커지면 추가 비용은 더 높아지기 마련이다. MySQL에서 쓰기 작업의 성능이 급격하게 떨어지는 임계치는 1~3억건 수준이라고 생각한다. 레코드 건수가 너무 많아져 INSERT 같은 작업이 심각하게 느려지고 있다면 파티션 적용을 고려해 보는 것이 좋다.