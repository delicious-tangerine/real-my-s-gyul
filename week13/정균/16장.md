# `16.7.1 MySQL 표준 설정의 필요성`

MySQL 서버의 특성상 `기본 확장 방식은 하드웨어의 성능을 업그레이드 하는 방법(스케일 업)이 아니라 똑같은 성능의 하드웨어를 장착한 서버의 대수를 늘리는 형태(스케이 아웃) 입니다.`

MySQL 서버의 이런 특성으로 인해 MySQL 서버는 하나의 인스턴스에 많은 데이터가 관리되기보다는 복수의 MysQL 인스턴스에 골고루 데이터를 분포시키는 방식이 많이 사용됩니다. 이런 이유로 MySQL 서버를 위한 장비나 인스턴스의 개수가 많아져서 MySQL 서버의 설치와 설정이 아주 빈번하게 발생합니다. 이 때 마다 MySQL 서버를 빌드해서 설치하고 설정 파일을 그 때 그 때 작성한다면 아마도 중요한 설정 뿐 아니라 중요하지 않은 설정까지도 자주 잊어버릴 확률이 높습니다. 

아마 대부분 새로운 MySQL을 설치할 때 이미 서비스에 사용되고 있는 MySQL 서버로부터 설정 파일을 가져와서 그 내용을 조금 변경해 또 다른 서비스에 투입하는 것이 일반적일 것입니다.

예를들어, `sort_buffer_size` 설정 값을 살펴보면, 어떤 값이 최적인지 판단하기 쉽지 않을 것입니다. 그런데 다른 서비스의 값을 가져와서 사용하면 좋지 않을 것입니다. 

![스크린샷 2021-09-11 오전 1 32 16](https://user-images.githubusercontent.com/45676906/132886981-75f51efb-5b09-476b-afd4-c1f9afdc3adc.png)

<br>

![스크린샷 2021-09-11 오전 1 32 21](https://user-images.githubusercontent.com/45676906/132886996-4d99bac7-a53a-4913-a496-98c06ee2dbec.png)

뭐가 뭔지.. 모르겠지만 어떤 설정하는데 사용되는 거 같습니다. 

<br> <br>

## `16.8 복제를 사용하지 않는 MySQL 설정`

MySQL에서 복제를 사용하려면 `바이너리 로그 파일`이 활성화되어야 합니다. MySQL의 시스템 설정 값 중에 `log-bin` 이라는 설정에 파일 이름이나 파일 경로가 명시되면 MySQL은 무조건 바이너리 로그를 활성화 합니다. 

하지만 MySQL의 바이너리 로그는 상당히 고비용의 디스크 I/O 작업을 필요로 합니다. 또한 바이너리 로그가 안전하게 슬레이브 MySQL 서버에 전달되게끔 MySQL 서버는 내부적으로 `갭 락과 넥스트 키 락`을 사용합니다. 즉 바이너리 로그는 I/O 부하뿐 아니라 InnoDB 테이블의 잠금까지도 영향을 미치게 됩니다. 즉, 바이너리 로그는 I/O 부하뿐 아니라 InnoDB 테이블의 잠금까지도 영향을 미치게 되며, 이는 MySQL 서버의 전체적인 성능과 동시성까지 저하시키는 효과를 가져오게 된다는 것을 의미합니다. 

`결론적으로 복제를 사용하지 않는 MySQL 서버에서는 바이너리 로그를 비활성화하고, InnoDB가 갭락과 넥스트 키 락을 사용하지 않게 트랜잭션 격리 수준을 READ-COMMITTED로 사용하는 것이 가장 좋습니다.` 

<br> <br>

## `16.9 MySQL 복제의 형태`

MySQL의 복제는 `하나의 슬레이브 MySQL이 둘 이상의 마스터 MySQL을 가질 수 없다.` 라는 제약만 피한다면 어떤 형태로든 구성할 수 있습니다. 10대의 MySQL 서버를 차례대로 줄을 세워서 일렬로 복제를 구성하는 것도 가능하며, 두 대의 장비가 각각 다른 장비의 마스터가 되는 마스터-마스터 형태의 복제도 가능합니다. 

<br>

### `1:M 복제`

![스크린샷 2021-09-11 오전 1 41 25](https://user-images.githubusercontent.com/45676906/132888063-1bf47d78-44ad-4b83-ac30-2da492431df6.png)

하나의 마스터 MySQL 서버에 2개 이상의 슬레이브 MySQL을 연결시키는 복제 형태를 말합니다. 위의 그림 복제 형태가 `서비스용으로 가장 자주 사용되는 복제의 형태`인데, 쿼리의 요청 수가 아주 많다면 마스터와 슬레이브 간에 적절히 분산해서 실행하는 것이 가능합니다. 

일반적으로 MySQL의 복제 구성에서 슬레이브 MySQL 서버는 읽기 전용으로 설정해서 마스터와 슬레이브의 데이터가 달라지지 않게 해줍니다. 그래서 프로그램에서도 데이터 변경이 필요한 트랜잭션은 마스터 MySQL에서 실행하고, SELECT만 필요한 작업은 슬레이브에서 실행하도록 역할을 구분해서 사용합니다. 

MySQL의 복제는 비동기 방식으로 마스터의 데이터가 슬레이브로 전달됩니다. 즉, 마스터 MySQL 서버에서 이미 커밋된 데이터라 하더라도 커밋된 시점에 슬레이브에는 그 데이터가 아직 전달되지 않았을수도 있다는 것을 의미합니다.

그래서 만약 INSERT, UPDATE 문장의 실행과 동시에 변경된 데이터를 SELECT 하는 쿼리를 슬레이브 MySQL에서 실행하면 `데이터가 없다` 라는 응답을 받을 수도 있습니다. 따라서 데이터를 변경함과 동시에 SELECT 하는 쿼리는 마스터 MySQL 서버에서 실행하는 것이 좋습니다. 

일반적으로 특별한 문제가 없다면 마스터 MySQL 서버에서 실행된 쿼리는 늦어도 1초 미만의 짧은 시간 내에 슬레이브 MySQL 서버에도 적용됩니다. 

<br> <br>

## `1:M:M 복제`

![스크린샷 2021-09-11 오전 1 49 15](https://user-images.githubusercontent.com/45676906/132889096-08b1f2bb-be59-4b09-a059-724cf872022a.png)

1:M 복제 구조에서 슬레이브 MySQL 서버가 너무 많아서 마스터 MySQL 서버의 성능에 악영향이 예상된다면 위의 그림과 같은 복제를 고려해볼 수 있습니다. 

MySQL 복제에서 마스터 MySQL은 슬레이브 MySQL이 요청할 때마다 계속 바이너리 로그를 읽어서 전달해야 합니다. 그래서 만약 하나의 마스터 MySQL에 연결된 슬레이브 MySQL의 개수가 많다면 바이너리 로그를 읽고 전달하는 작업 자체가 부하가 될 수도 있습니다. 

- 잠시 생략

<br> <br>

## `16.9.2 확장(스케일 아웃)`

MySQL의 복제는 읽기를 확장하는 방법이지 쓰기를 확장하는 방법은 아닙니다. 복제가 구축된 MySQL 서버라 하더라도 쓰기 작업은 마스터 MySQL로 집중될 수 밖에 없으므로 최대한 읽기 작업을 슬레이브로 옮겨야 마스터 MySQL이 쓰기 작업에만 집중할 수 있습니다.

<br> <br>

## `16.9.3 가용성`

마스터 MySQL 서버에 문제가 발생한다면 슬레이브 MySQL 서버를 마스터로 승격시켜서 서비스를 복구하는 것도 가능합니다. (하지만 데이터의 정합성이 생명인 DBMS에서 슬레이브를 자동으로 마스터로 변경해 버리는 것은 상당히 위험성이 있는 작업이므로 많은 주의와 테스트가 필요합니다.)

<br> <br>

## `16.10 SQL 작성 표준`

### `16.10.1 조인 조건은 항상 ON 절에 기재`

```sql
SELECT *
FROM employees e
LEFT JOIN dept_manager dm
WHERE e.fist_name = 'Smith'
AND dm.emp_no = e.emp_no;
```

JOIN의 조건을 WHERE에 사용한다면 MySQL 옵티마이저가 LEFT JOIN이 아니라 INNER JOIN으로 고쳐서 실행해 버리므로, 의도한 결과와는 다른 결과가 나오게 됩니다. 

<br> <br>

## `16.10.2 테이블 별칭 사용 및 컬럼 명에 테이블 별칭 포함`

일반적으로 테이블이 하나만 사용되는 쿼리에서는 특정 컬럼이 어느 테이블의 컬럼인지 고민할 필요가 없지만, 여러 테이블이 조인되는 쿼리에서는 테이블의 별칭을 표기하지 않으면 구분하기가 쉽지 않습니다. 

```sql
SELECT first_name, last_name
FROM employees e INNER JOIN dept_manager dm ON dm.emp_no=em.emo_no
WHERE first_name='Smith'
```

만약에 dept_manager 테이블에 first_name 컬럼이 추가되는 순간부터 이 쿼리는 컬럼명이 모호하다는 에러를 발생하면서 실행이 멈춰 버릴 것입니다. 그래서 가능하다면 여러 테이블의 조인 여부와 상관 없이 짧은 이름으로 테이블의 별칭을 부여하고, 모든 컬럼의 이름 앞에는 테이블의 별칭을 붙이는 습관을 들이는 것이 좋습니다. 

<br> <br>

## `DELETE, UPDATE 쿼리에서 ORDER BY ... LIMIT 사용 자제`

MySQL 5.0 까지는 DELETE나 UPDATE 쿼리에 ORDER BY ... LIMIT 형태의 쿼리를 실행해도 아무런 문제가 없었습니다. 하지만 복제가 구축된 MySQL에서는 이러한 쿼리가 마스터와 슬레이브의 데이터를 달라지게 만들 수도 있었습니다. 그래서 MySQL 5.1 부터는 이러한 쿼리가 마스터 MySQL에서 실행되면 경고 메세지를 출력하고, 쿼리를 강제종료 할 때도 있었습니다. 

<br> <br>

## `16.10.7 서브쿼리는 조인으로 변경`

쿼리를 작성할 때 많은 사람들이 공통적인 성향 중 하나가 뼈대 쿼리를 작성하고, 그 쿼리를 괄호로 묶어서 서브쿼리로 만들어 버린다는 것입니다. 그런데 문제는 현재 많이 사용되고 있는 MySQL 5.0, 5.1, 5.5 버전 모두 서브 쿼리를 최적화하는 능력이 상당히 부족하다는 것입니다. 

즉, 임시테이블이 생길 수 있는 문제도 있고, 서브 쿼리를 제거하는 것이 좋습니다. 또한 MySQL 최근 버전에서는 조인의 최적화가 상당히 높은 수준이므로 서브 쿼리보다는 조인을 사용하는 것이 여러모로 좋습니다. 

<br> <br>

## `16.10.8 UNION ALL은 사용 자제`

MySQL의 UNION은 항상 내부적으로 임시 테이블을 만들어 버퍼링한 다음에 사용자에게 결과를 반환합니다. 이 작업은 대량의 레코드를 처리하는 쿼리에서는 상당히 부담될 것입니다. 여러 집합의 중복된 레코드를 제거해야 하는 UNION을 꼭 사용해야 한다면 특별한 우회 방법은 없습니다. 하지만 중복 제거 없이 UNION ALL로 가능한 쿼리는 두 개의 쿼리 문장으로 분리해서 쿼리를 실행하는 편이 훨씬 더 효율적으로 처리될 수 있다는 점을 기억하기!!

<br> <br>

## `16.10.11 UPDATE, DELETE 쿼리와 적용 건수 체크`

일반적으로 한 건의 레코드를 INSERT 하는 쿼리는 성공하면 1, 실패하면 0으로 처리된 레코드 건수가 에러 여부에 따라 상당히 명확합니다. 하지만 UPDATE, DELETE 문장은 쿼리의 성공적인 실행 여부를 업무적인 정상 처리 여부로 판단하기에는 부족할 수 있습니다. 즉, 처리된 레코드 건수를 반드시 검증하는 형태의 프로그램 로직을 추가하는 습관을 들이는 것이 좋습니다. 

<br> <br>

## `16.10.12 숫자 값은 반드시 숫자 타입의 컬럼으로 정의`

문자열 타입에 숫자 값이 저장될 때, 문자열 타입에 저장된 숫자 값을 비겨하기 위해 `char_type_column=2`와 같은 형태로 쿼리를 사용할 때가 많았습니다. 하지만 이 조건을 위해 MySQL 옵티마이저는 뒤의 숫자 값을 문자열로 바꿔서 비교하는 것이 아니라 앞의 문자열 컬럼을 모두 숫자로 변환해서 비교를 수행합니다. 

<br> <br>

## `RAID 컨트롤러`

DBMS는 한번에 많은 디스크 I/O를 유발하는 것이 아니라, 아주 빈번하게 자그만한 디스크 I/O를 유발하는 특징이 있습니다. 이런 DBMS의 디스크 I/O 특징을 감안하면 DBMS용 장비에서 RAID 컨트롤러는 필수라고 볼 수 있습니다. 
