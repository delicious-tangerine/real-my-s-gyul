# B-Tree 인덱스
B-Tree의 B는 Binary가 아니라 Balanced다!<br><br>

B-Tree는 원래 값을 변형시키지 않고 인덱스 구조체 내에서는 항상 정렬된 상태로 유지 하고 있다. 전문 검색과 같은 특수한 요건이 아닌 경우, 대부분 인덱스는 거의 B-Tree를 사용할 정도로 일반적인 용도에 적합한 알고리즘이다.

## 구조 및 특성
B-Tree는 루트 노드(맨 위), 리프 노드(맨 아래), 브랜치 노드(가운데) 로 구성 되어 있다.<br>
인덱스의 키 값은 모두 정렬돼 있지만 데이터 파일의 레코드는 정렬돼 있지 않고 임의의 순서대로 저장돼 있다.

## B-Tree 인덱스 키 추가 및 삭제
### 인덱스 키 추가
새로운 키 값이 B-Tree에 저장될 때 테이블의 스토리지 엔진에 따라 새로운 키값이 즉시 인덱스에 저장될 수도 있고 그렇지 않을 수도 있다. B-Tree에 저장될 때는 저장될 키값을 이용해 B-Tree상의 적절한 위치를 검색해야 한다.

### 인덱스 키 삭제
삭제되는 경우는 간단하다. 해당 키값이 저장된 B-Tree의 리프 노드를 찾아서 그냥 삭제 마크만 하면 작업이 완료 된다. 이렇게 삭제 마킹된 인덱스 키 공간은 계속 그대로 방치하거나 또는 재활용할 수 있다.

### 인덱스 키 변경
인덱스의 키값은 그 값에 따라 저장될 리프 노드의 위치가 결정되므로 B-Tree의 키값이 변경되는 경우에는 단순히 인덱스상의 키값만 변경하는 것은 불가능하다. 키값 변경은 삭제 후 다시 새로운 키값을 추가하는 형태로 처리된다.

### 인덱스 키 검색
루트 노드 부터 시작 해서 브랜치 노드를 거쳐 리프 노드 까지 탐색 한다. 이 과정을 트리 탐색 이라고 한다. SELECT에서만 사용 되는 것이 아니라 UPDATE, DELETE를 처리 하기 위해서도 사용 된다.

## B-Tree 인덱스 사용에 영향을 미치는 요소
- 인덱스 키값의 크기
- B-Tree 깊이
- 선택도 ( 인덱스 키 값 가운데 유니크한 값의 수 )
- 읽어야 하는 레코드의 건수

키 값의 크기는 가능하면 작게 만드는 것이 좋다. 실제로 아무리 대용량 데이터 베이스라도 B-Tree의 깊이가 4~5 이상까지 깊어지는 경우는 거의 발생하지 않는다.


## B-Tree 인덱스를 통한 데이터 읽기
- 인덱스 풀 스캔
- 인덱스 레인지 스캔
- 인덱스 루스 스캔(인덱스를 스킵 하며 읽는다.)