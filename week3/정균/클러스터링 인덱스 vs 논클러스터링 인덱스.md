# `Cluster Index vs Non-Cluster Index`

인덱스에서 클러스터링은 값이 비슷한 것들을 묶어서 저장하는 형태로 구현됩니다. 
MySQL에서 클러스터링 인덱스는 `InnoDB`와 `TokuDB` 스토리지 엔진에서만 지원하며, 나머지 스토리지 엔진에서는 지원되지 않습니다. 

<br> <br>

## `Cluster Index`

`클러스터링 인덱스는 테이블의 프라이머리 키에 대해서만 적용`되는 내용입니다. `즉, 프라이머리 키 값이 비슷한 레코드끼리 묶어서 저장하는 것을 클러스터링 인덱스`라고 표현합니다.
여기서 중요한 것은 프라이머리 키 값에 의해 레코드의 저장 위치가 결정된다는 것입니다. 
또한 프라이머리 키 값이 변경된다면 그 레코드의 물리적인 저장 위치가 바뀌어야 한다는 것을 의미하기도 합니다.

프라이머리 키 값으로 클러스터링된 테이블은 프라이머리 키 값 자체에 대한 의존도가 상당히 크기 때문에 신중히 프라이머리 키를 결정해야 합니다.

클러스터링 인덱스는 프라이머리 키 값에 의해 레코드의 저장 위치가 결정되므로 사실 인덱스 알고리즘이라기보다 테이블 레코드의 저장 방식이라고 볼 수도 있습니다.
그리고 일반적으로 InnoDB와 같이 항상 클러스터링 인덱스로 저장되는 테이블은 프라이머리 키 기반의 검색이 매우 빠르며, 대신 레코드의 저장이나 프라이머리 키의 변경이 상대적으로 느릴 수 밖에 없습니다.

![스크린샷 2021-08-15 오후 5 19 53](https://user-images.githubusercontent.com/45676906/129471987-cb6103d1-c9ff-4ffd-b562-c53e96894e7f.png)

위의 그림처럼 클러스터링 인덱스 구조를 보면 클러스터링 테이블의 구조 자체는 일반 B-Tree와 많이 비슷합니다.
하지만 B-Tree의 리프 노드와는 달리 위의 그림의 클러스터링 인덱스의 리프 노드에는 레코드의 모든 컬럼이 저장되어 있는 것을 볼 수 있습니다.

```sql
UPDATE tb_test SET emp_no=10002 WHERE emp_no=10007;
```

위와 같이 emp_no 테이블의 프라이머리 키인 emp_no를 변경하는 Update 쿼리를 실행하면 어떤 과정이 일어날까요? (실제로 프라이머리 키가 변경되는 경우는 거의 없겠지만,,)

<br>

![스크린샷 2021-08-15 오후 5 24 35](https://user-images.githubusercontent.com/45676906/129472101-5ea89eb1-e51a-4be5-b773-a72602bd3344.png)

emp_no가 10007인 값이 10002로 변경되니 위와 같이 페이지 3번에서 2번으로 이동한 것을 볼 수 있습니다. 이런 것이 `클러스터링 인덱스`의 저장 방식 특징이라고 할 수 있습니다.

> MyISAM 테이블이나 기타 InnoDB를 제외한 테이블의 데이터 레코드는 프라이머리 키나 인덱스 키 값이 변경된다고 해서 실제 레코드의 위치가 변경되지는 않는다. 데이터 레코드가 INSERT 될 때 데이터 파일의 끝 또는 빈공간에 저장됩니다. 
> 이렇게 한번 결정된 위치는 절대 바뀌지 않습니다.

<br> <br>

## `프라이머리 키가 없는 InnoDB 테이블이라면 어떻게 클러스터 테이블로 구성될까?`

프라이머리 키가 없는 경우에는 InnoDB 스토리지 엔진이 아래의 우선순위대로 프라이머리 키를 대체할 컬럼을 선택합니다.

1. 프라이머리 키가 있으면 기본적으로 프라이머리 키를 클러스터 키로 선택
2. NOT NULL 옵션의 유니크 인덱스(UNIQUE INDEX) 중에서 첫 번째 인덱스를 클러스터 키로 선택
3. 자동으로 유니크한 값을 가지도록 증가되는 컬럼을 내부적으로 추가한 후, 클러스터 키로 선택

<br>

InnoDB 스토리지 엔진이 적절한 클러스터 키 후보를 찾지 못해서 내부적으로 자동 증가 컬럼을 추가한 경우, 자동 추가된 컬럼은 사용자에게 노출되지 않으며, 쿼리 문장에 명시적으로 사용할 수 없습니다.
즉, 프라이머리 키나 유니크 인덱스가 전혀 없는 InnoDB 테이블에서 아무런 의미 없는 숫자 값으로 클러스터링 되고 있는 것입니다. 

즉, 클러스터링 인덱스는 InnoDB 테이블별로 단 한번만 가질 수 있는 것이므로 가능하다면 프라이머리 키를 명시하는 것이 좋습니다.

<br> <br>

## `Cluster 인덱스의 장점과 단점`

### 장점

- 프라이머리 키로 검색할 때 처리 성능이 매우 빠름
- 테이블의 모든 보조 인덱스가 프라이머리 키를 가지고 있기 때문에 인덱스만으로 처리될 수 있는 경우가 많음

<br>

### 단점

- 테이블의 모든 보조 인덱스가 클러스터 키를 갖기 떄문에 클러스터 키 값의 크기가 클 경우 전체적으로 인덱스의 크기가 커짐
- 보조 인덱스를 통해 검색할 때 프라이머리 키로 다시 한번 검색해야 하므로 처리 성능이 조금 느림
- 프라이머리 키를 변경할 때 레코드를 DELETE 하고 INSERT 하는 작업이 필요하기 때문에 처리 성능이 느림

<br> <br>

## `클러스터 테이블 사용 시 주의사항`

MyISAM과 같이 클러스터링되지 않은 테이블에 비해 InnoDB(클러스터 테이블)에서는 조금 더 주의해야 할 사항이 있습니다.

<br>

### 클러스터 인덱스 키의 크기

클러스터 테이블의 경우, 모든 보조 인덱스가 프라이머리 키 값을 포함합니다. 그래서 프라이머리 키의 크기가 커지면 보조 인덱스도 자동으로 크기가 거집니다. 보통 보조 인덱스는 4~5개 있다고 가정하면 보조 인덱스 크기는 급격히 증가합니다.
즉, InnoDB 테이블의 프라이머리 키는 신중하게 선택해야 합니다.

<br>

### 프라이머리 키는 AUTO-INCREMENT 보다는 업무적인 컬럼으로 생성할 것(가능한 경우)

InnoDB의 프라이머리 키는 클러스터 키로 사용되며, 이 값에 의해 레코드의 위치가 결정된다고 하였습니다. 즉, 프라이머리 키로 검색하는 경우 클러스터되지 않은 테이블에 비해 매우 빠르게 처리될 수 있음을 의미합니다.  

<br>

### 프라이머리 키는 반드시 명식할 것

가끔 프라이머리 키가 없는 테이블을 자주 보게 되는데, 가능하면 AUTO_INCREMENT 컬럼을 이용해라도 프라이머리 키는 설정하길 권장합니다. InnoDB 테이블에서 프라이머리 키를 정의하지 않으면 AUTO_INCREMENT와 같은 자동 증가 컬럼을 내부적으로 추가합니다. 하지만 자동으로 추가된 컬럼은 사용자에게 보이지 않기 때문에 SQL에서 전혀 사용할 수 없습니다.
즉, InnoDB 테이블에 프라이머리 키를 정의하지 않는 경우와 AUTO_INCREMENT 컬럼을 생성하고 프라이머리 키로 설정하는 것이 결국 똑같다는 것입니다. 그렇기에 사용자가 사용할 수 있는 프라이머리 키를 설정하는 것이 좋습니다.

<br>

### AUTO-INCREMENT 컬럼을 인조 식별자로 사용할 경우

여러 개의 컬럼이 복합으로 프라이머리 키가 만들어지는 경우 프라이머리 키의 크기가 길어질 때가 가끔 있습니다. 하지만 프라이머리 키의 크기가 길어도 보조 인덱스가 필요치 않다면 그대로 프라이머리 키를 사용하는 것이 좋습니다.
만약 보조 인덱스도 필요하고 프라이머리 키의 크기도 길다면 AUTO-INCREMENT 컬럼을 추가하고 이를 프라이머리 키로 설정하면 됩니다. 이렇게 프라이머리 키를 대체하기 위해 인위적으로 추가된 프라이머리 키를 `인조 식별자` 라고 합니다.

<br> <br>

# `Non-Cluster Index`

논 클러스터 인덱스는 해당 키 값이 포함된 데이터 행에 대한 포인터가 존재합니다.

![스크린샷 2021-08-15 오후 5 59 27](https://user-images.githubusercontent.com/45676906/129473008-6d52578f-c155-48cf-9d09-f4775f2a9090.png)

위의 그림과 같이 `45번은 123번지로 가면 있고, 20번은 231번지로 가면 데이터 존재한다`와 같이 해석할 수 있습니다.

그래서 데이터를 읽어올 때는 `클러스터링 인덱스` 보다 느립니다. (포인터로 한 단계를 더 거쳐서 읽어야 하기 때문에) 반면에 클러스터링 인덱스처럼 INSERT, DELETE, UPDATE 시에 재정렬 작업의 오버헤드가 적기 때문에 쓰기 작업을 더 빠르게 할 수 있다는 특징을 가지고 있습니다.

즉, Non-Cluster 인덱스는 책의 목차라고 생각하면 나쁘지 않은 비유인 거 같습니다.

<br> <br>

# `Reference`

- Real MySQL