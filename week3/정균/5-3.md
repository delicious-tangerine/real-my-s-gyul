# `5-3 B-Tree 인덱스`

- B-Tree는 데이터베이스의 인덱싱 알고리즘 가운데 가장 일반적으로 사용됨

- B는 Binary가 아니라 Balanced 임 ~ 

- 전문 검색과 같은 특수한 요건이 아닌 경우, 대부분 인덱스는 거의 B-Tree를 사용할 정도로 일반적인 용도에 적절함

<br>

## `구조 및 특성`

<img width="592" alt="스크린샷 2021-06-13 오후 11 31 27" src="https://user-images.githubusercontent.com/45676906/121811473-7a615e80-cc9f-11eb-94cd-2622fbc7aaa9.png">

- 루트, 리프, 브랜치 노드가 존재

- 인덱스의 리프 노드는 항상 실제 데이터 레코드를 찾아가기 위한 주소 값을 가지고 있음

<br>

<img width="498" alt="스크린샷 2021-06-13 오후 11 35 03" src="https://user-images.githubusercontent.com/45676906/121811644-fbb8f100-cc9f-11eb-908c-1876b691c55f.png">

- 인덱스는 테이블의 키 컬럼만 가지고 있으므로 나머지 컬럼을 읽으려면 데이터 파일에서 해당 레코드를 찾아야 한다. 

<br>

## `B-Tree 인덱스 키 추가 및 삭제`

- 테이블의 레코드를 저장하거나 변경하는 경우, 인덱스 키 추가나 삭제 작업이 발생

- B-Tree에 저장될 때는 저장될 키 값을 이용해 B-Tree 상의 `적절한 위치를 검색`해야 함 

<br>

## `인덱스 키 삭제`

- 해당 키 값이 저장된 B-Tree 리프 노드를 찾아서 그냥 삭제 마크만 하면 작업 완료

<br>

## `인덱스 키 변경`

- 인덱스의 키 값은 그 값에 따라 저장될 리프 노드의 위치가 결정되므로 B-Tree의 키 값이 변경되는 경우에는 단순히 인덱스상의 키 값만 변경 불가능

- B-Tree의 키 값 변경 작업은 먼저 키 값을 삭제한 후, 다시 새로운 키 값을 추가하는 형태로 처리

<br>

## `인덱스 키 검색`

- INSERT, UPDATE, DELETE 작업을 할 때 인덱스 관리에 따르는 추가 비용을 감당하면서 인덱스를 구축하는 이유는 `빠른 검색`을 위해서다. 

- 인덱스를 검색하는 작업은 B-Tree 루트 노트로부터 시작해 브랜치 노드를 거쳐 최종 리프 노드까지 이동하면서 비교 작업을 수행 (`트리 탐색`)

- B-Tree 인덱스를 이용한 검색은 100% 일치 or 값의 앞부분만 일치하는 경우에 사용할 수 있다. (Like %keyword% 처럼 양쪽에 % 쓰면 인덱스 안탄다고 들었던 거 같은데 요것..?)


<br>

## `B-Tree 인덱스 사용에 영향을 미치는 요소`

- 인덱스를 구성하는 칼럼의 크기와 레코드 수

- 유니크한 인덱스 키 값의 개수

위의 것들이나 등등에 의해 검색이나 변경 작업의 성능이 영향을 받음

<br>

### `인덱스 키 값의 크기`

- InnoDB 스토리지 엔진은 디스크에 데이터를 저장하는 가장 기본 단위를 페이지 또는 블록이라고 하며, 디스크의 모든 읽기 및 쓰기 작업의 최소 작업 단위가 된다. 

- 인덱스도 페이지 단위로 관리 되며, Depth 마다 페이지 라고 함

- B-Tree 가 이진 트리라면 어떨까? 상당히 비효율적일 것

- InnoDB 페이지 크기는 16KB로 고정되어 있음. 

<br>

### `B-Tree 깊이와 인덱스 키 크기 관계`

- 인덱스 페이지(16KB)에 대략 585개 저장할 수 있음

- 인덱스 키 크기가 16 -> 32로 늘어나면? 372개 저장할 수 있음

- 그러면.. 500개를 SELECT 해와야 한다면 전자는 한번에 가능, 후자는 2번 디스크를 읽어와야 함

- 즉, 인덱스 키 값의 길이가 길어진다는 것은 전체적인 인덱스의 크기가 커진다는 것을 의미

- `그러면 깊이는 어떨끼?` 키 값이 16바이트면 최대 2억대 키를 한 Depth에 담을 수 있음

- 32바이트로 늘어나면 5천만개로 줄어듬 -> `B-Tree 깊이는 MySQL에서 값을 검색할 때 몇 번이나 랜덤하게 디스크를 읽어야 하는지와 직격되는 문제`

- `결론적으로 인덱스 키 값의 크기가 커지면 커질수록 하나의 인덱스 페이지가 담을 수 있는 인덱스 키 값의 개수가 작아지고, 그 때문에 같은 레코드 건수라 하더라도 B-Tree Depth가 깊어져서 디스크 읽기가 더 많이 필요하게 된다는 것을 의미`

- "인덱스 크기는 가능하면 작게 만들자" 아무리 대용량 DB여도 depth는 4~5 이상은 거의 없기에

<br>

## `읽어야 하는 레코드의 건수`

- 인덱스를 통해 테이블의 레코드를 읽는 것은 인덱스를 거치지 않고 바로 테이블의 레코드를 읽는 것보다 높은 비용이 드는 작업이다. 

- 일반적인 DBMS에서는 인덱스를 통해 레코드 1건을 읽는 것이 테이블에서 직접 레코드 1건을 읽는 것보다 4~5배 정도 더 비용이 많이 드는 작업인 것으로 예측

- 즉, 인덱스를 통해 읽어야할 레코드의 건수가 전체 테이블의 레코드의 20~25%를 넘어서면 인덱스를 이용하지 않고 직접 테이블을 모두 읽어서 필요한 레코드만 가려내는 방식으로 처리하는 것이 효율적
  - 예시를 들면? 

<br>

### `인덱스 레인지 스캔`

- 인덱스 접근 방식 중에 가장 대표적이고 빠른 방법

<img width="505" alt="스크린샷 2021-06-14 오전 11 16 22" src="https://user-images.githubusercontent.com/45676906/121831242-f3919d80-cd01-11eb-8c6f-ccd3f0e3bfa2.png">

- 인덱스 레인지 스캔은 검색해야 할 인덱스의 범위가 결정됐을 때 사용하는 방식

- 검색하려는 값의 수나 검색 결과 레코드 건수와 관계없이 `레인지 스캔`이라고 표현

<br>

![스크린샷 2021-06-14 오전 11 18 25](https://user-images.githubusercontent.com/45676906/121831375-410e0a80-cd02-11eb-848c-c934ec595cb1.png)

- 위 그림은 인덱스의 리프 노드를 스캔하면서 실제 데이터 파일의 레코드를 읽어 와야 하는 경우

- 인덱스의 리프 노드에서 검색 조건에 일치하는 건들은 데이터 파일에서 레코드를 읽어오는 과정이 필요함

- 이 때 리프 노드에 저장된 레코드 주소로 데이터 파일의 레코드를 읽어오는데, 레코드 한 건 한 건 단위로 랜덤 I/O가 한번씩 실행됨 

- 질문,, 인덱스를 통해서 결국에는 데이터 레코드를 읽어 와야 겠는 ?

<br>

## `인덱스 풀 스캔`

- 인덱스 레인지 스캔과 마찬가지로 인덱스를 사용하지만 인덱스 레인지 스캔과는 달리 `인덱스의 처음부터 끝까지 모두 읽는 방식을 인덱스 풀 스캔`이라고 함

![스크린샷 2021-06-14 오전 11 40 49](https://user-images.githubusercontent.com/45676906/121832615-6bad9280-cd05-11eb-9dcf-913d6c74e7f9.png)

- 인덱스의 리프 노드를 연결하는 링크드 리스트를 따라서 처음부터 끝까지 스캔하는 방식을 `인덱스 풀 스캔`이라고 함

- 인덱스 레인지 스캔보다는 빠르지 않지만 테이블 풀 스캔보다는 효율적

- 테이블 자체의 크기보다는 훨씬 작으므로 인덱스 풀 스캔은 테이블 전체를 읽는 것보다는 적은 디스크 I/O로 쿼리 처리 가능

<br>

## `루스 인덱스 스캔`

- 첨 들어봄.. 

- 느슨하게 듬성듬성 인덱스를 읽는 것을 의미함

- 인덱스 레인지 스캔과 비슷하게 작동하지만, 중단마다 필요치 않은 인덱스 키값은 무시하고 다음으로 넘어가는 형태

<br>

## `다중 칼럼(Multi-column) 인덱스`

- 실제 서비스용 디비에서는 2개 이상의 컬럼을 포함하는 인덱스가 더 많이 사용됨

- 두 개 인덱스가 있어도 왼쪽에 있는 인덱스로 먼저 정렬이 되고 왼쪽 인덱스 값이 같다면 그 때 두 번째 인덱스로 정렬 됨


<br>

## `인덱스 스캔 방향`

```sql
SELECT *
FROM employees ORDER BY first_name DESC
LIMIT 1
```

위의 쿼리는 어떻게 실행될까? MySQL은 인덱스를 처음부터 오름차순으로 끝까지 읽어 first_name이 가장 큰(오름차순에서 가장 마지막 레코드) 값 하나를 가져오는 것일까? 

아니다. `인덱스는 항상 오름차순으로만 정렬돼 있지만 인덱스를 최소값붵 읽으면 오름차순으로 값을 가져올 수 있고, 최대값부터 거꾸로 읽으면 내림차순으로 값을 가져올 수 있다는 것을 MySQL 옵티마이저는 알고 있다` (오.. 그렇군)

그래서 쿼리는 인덱스를 역순으로 접근해 첫 번째 레코드만 읽으면 된다. 즉, MySQL 옵티마이저는 인덱스의 읽기 방향을 전환해서 사용하도록 `실행 계획`을 만들어 낸다. 

<br>

## `가용성과 호율성 판단`

기본적으로 B-Tree 인덱스의 특성상 다음 조건에서는 작업 범위 결정 조건으로 사용할 수 없다. 

- NOT-EQUALS로 비교된 경우

