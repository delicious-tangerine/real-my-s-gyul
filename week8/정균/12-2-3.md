# `UPDATE 쿼리의 잠금`

```sql
UPDATE ... WHERE ...
```

단순 UPDATE 문장은 WHERE 조건에 일치하는 레코드를 찾기 위해 참조한 모든 레코드에 베타적 넥스트 키 락을 걸게 됩니다. 단순 레코드만 잠그지 않고 간격까지 잠그는 것은 `팸턴 레코드`의 발생을 막기 위한 것입니다. 일반적으로 넥스트 키 락(레코드와 레코드 간의 갭을 동시에 잠그는 락)을 설정하는 이유는 이 처리가 수행되는 동안 다른 트랜잭션에 의해 처리 범위의 레코드가 영향을 받지 않게 하기 위해서입니다.

<br>

```sql
UPDATE tb_test1 a, tb_test2 b ON ... SET a.column = b.column
```

JOIN UPDATE 문장에서는 여러 개의 테이블이 동시에 사용되는데, 최종적으로 UPDATE 되는 컬럼이 포함된 모든 테이블의 레코드에는 배타적 넥스트 키 락이 걸리고, 그 밖의 단순 참조용으로만 사용되는 테이블에는 공유 넥스트 키락이 설정됩니다.
단순 참조 테이블에 공유 넥스트 키 락을 거는 이유는 `INSERT INTO ... SELECT ...` 쿼리와 같이 팬턴 레코드의 발생을 방지하고 복제에서 마스터와 슬레이브의 데이터 동기화를 유지하기 위해서입니다. (이해가 잘 안되는..)

UPDATE tb_test1 a, tb_test 2 ON a.column = b.column ... 문장에서는 테이블의 컬럼이 변경되므로 tb_test1 테이블에는 베타적 잠금이 걸리고, 단순 참조만 하는 tb_test2 테이블에서 조인에 참여한 레코드는 공유 잠금이 걸립니다.

<br> <br>

# `DELETE 쿼리의 잠금`

```sql
DELETE FROM ... WHERE ...
```

단순 DELETE 문장은 UPDATE 문장과 똑같이 WHERE 조건에 일치하는 레코드를 찾기 위해 참조한 모든 레코드에 대해 베타적 넥스트 키 락을 겁니다.
단순 레코드만 잠그지 않고 간겪까지 잠그는 것은 복제에서 마스터와 슬레이브의 동기화를 유지하기 위해서입니다. (간격까지 잠근다라..)
일반적으로 넥스트 키 락을 설정하는 이유는 이 처리가 수행되는 동안 다른 트랜잭션에 의해 처리 범위의 레코드가 변경되지 않게 하는 데 있습니다.

<br>

```sql
DELETE a FROM tb_tset1 a, tb_test2 b ...
```

JOIN DELETE 쿼리 문장도 JOIN UPDATE와 같이 하나의 쿼리에 여러 테이블이 동시에 사용됩니다. 이 때 최종적으로 DELETE 되는 레코드가 포함된 모든 테이블의 레코드에는 베타적 넥스트 키 락이 걸리고, 그 이외의 단순 참조용으로만 사용되는 테이블에는 공유 넥스트 키 락이 설정됩니다. 

`DELETE a FROM tb_tset1 a, tb_test2 b ...` 쿼리에서는 tb_test1 테이블의 레코드만 삭제되므로 tb_test1 테이블에서 삭제되는 레코드는 베타적 잠금이 걸리고, tb_test2 테이블에서 조인의 참조용으로 사용되는 레코드는 공유 잠금이 걸립니다.

<br> <br>

# `DDL 문장의 잠금`

```sql
CREATE TABLE tb_new ... SELECT ... FROM tb_old ...
```

이 쿼리 또한 INSERT INTO ... SELECT ... 쿼리 문장과 마찬가지로 읽어오는 테이블인 tb_old 테이블에는 읽기 잠금이 걸리고, tb_new 테이블에 INSERT 되는 레코드는 베타적 레코드 락이 설정됩니다.

`CREATE TABLE tb_new ... SELECT ... FROM tb_old ...` 문장은 DDL 문장이라서 쿼리가 완료됨과 동시에 트랜잭션도 자동으로 COMMIT 됩니다. 

> RENAME TABLE 명령은 하나의 명령으로 여러 개의 테이블에 대해 RENAME 하는 작업이 가능합니다.