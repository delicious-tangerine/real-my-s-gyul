# `SQL 문장별로 사용하는 잠금`

InnoDB 테이블은 각 쿼리의 종류별로 사용하는 잠금 방식이 다르고, 전혀 잠금을 사용하지 않을 것으로 예상되는 쿼리도 잠금을 사용하는 것이 있습니다. 어떤 것이 있는지 하나씩 알아보겠습니다. 

<br>

## `12.2.1 SELECT 쿼리의 잠금`

```sql
SELECT ... FROM ...

```

InnoDB 테이블에서 기본 형태의 SELECT 쿼리는 별도의 잠금을 사용하지 않습니다. 만약 읽어야 할 레코드가 다른 트랜잭션에 의해 변경되거나 삭제되는 중이라면 InnoDB에서 관리하고 있는 데이터의 변경 이력을 이용해 레코드를 읽습니다.

이처럼 InnoDB 테이블에서 SELECT만 수행할 때는 다른 트랜젹션의 쿼리에 영향을 받지 않으며, 별도로 레코드를 읽기 위해 대기하지도 않습니다. 또한 레코드를 읽을 때 별도의 잠금을 걸지도 않으며, DDL 문장으로 테이블의 구조가 변경되는 중에도 SELECT ... FROM ... 은 처리될 수 있습니다.

하지만 트랜잭션 격리 수준이 `SERIALIAZBLE`인 경우에는 아무런 잠금 옵션이 없는 SELECT 쿼리라 하더라도 LOCK IN SHARE MODE 옵션이 자동으로 덧붙여져서 실행되므로 읽기 잠금을 획득 후 읽기를 실행합니다.

<br>

```sql
SELECT ... FROM ... LOCK IN SHARE MODE
```

LOCK IN SHARE MODE 옵션이 사용된 SELECT 쿼리 문장은 WHERE 절에 일치하는 레코드뿐 아니라 검색을 위해 접근한 모든 레코드에 대해 공유 넥스트 키 락을 필요로 합니다.
만약 읽기 잠금을 걸어야 하는 레코드가 다른 트랜잭션에 의해 쓰기 잠금이 걸려 있다면 그 잠금이 해제될 때가지 기다려야 합니다. 하지만 다른 트랜잭션에 의해 읽기 잠금이 걸려있을 때는 읽기 잠금끼리는 상호 호환이 되므로 별도의 대기 없이 읽기 잠금을 획득할 수 있습니다.

<br>

```sql
SELECT ... FROM ... FOR UPDATE
```

FOR UPDATE 옵션이 사용된 SELECT 쿼리 문장도 WHERE 조건절에 일치하는 레코드를 검색하기 위해 접근한 모든 레코드에 대해 베타적 넥스트 키 락을 걸게 됩니다.

```
넥스트 키 락

레코드 락과 갭 락을 합쳐 놓은 형태의 잠금을 넥스트 키 락이라고 합니다. STATEMENT 포맷의 바이어리 로그를 사용하는 MySQL 서버에서는 REPEATABLE READ 격리 수준을 사용해야 합니다.
InnoDB의 갭 락이나 넥스트 키 락은 바이너리 로그에 기록되는 쿼리가 슬레이브에서 실행될 때 마스터에서 만들어 낸 결과와 동일한 결과를 만들어내도록 보장하는 것이 주 목적입니다. 
```

<br> <br>

## `12.2.2 INSERT 쿼리의 잠금`

```
INSERT ...
```

INSERT 문장은 기본적으로 베타적 레코드 잠금을 사용합니다. 만약 테이블에 프라이머리 키나 유니크 키가 존재한다면 중복 체크를 위해 공유 레코드 잠금을 먼저 획득해야 합니다. (너무 어렵..)
또한 MySQL의 INSERT 문장은 `인서트 인덱션 락(INSERT INTENTION LOCK)` 이라는 조금 색다른 잠금 방식도 사용합니다.

`인서트 인텍션 락`은 INSERT를 실행할 의도를 지닌 쿼리가 획득해야 하는 잠금으로, 모든 INSERT 쿼리는 인서트 인텍션 락을 획득한 후 INSERT를 실행해야 합니다. 그리고 INSERT된 레코드에 대해서는 베타적 잠금을 자동으로 획득하게 됩니다.  

인서트 인텍션 락은 갭락의 일종으로, 인서트 인텍션 락끼리는 서로 호환됩니다. 즉, 여러 트랜잭션이 동시에 인서트 인텍션 락을 획득할 수 있다는 것을 의미합니다. 하지만 이미 다른 트랜잭션이 레코드나 갭 락을 걸고 있다면 인서트 인텍션 락을 걸기 위해 기다려야 합니다.

InnoDB에서 인서트 인텍션 락을 사용하는 이유는 InnoDB의 갭 락으로 인한 동시성 감소를 최소화하기 위해서입니다.

```sql
CREATE TABLE tb_test {
    fdpk INT NOT NULL,
    PRIMARY key (kdpk)
}

INSERT INTO tb_test VALUES (1), (6), (8), (9)
```

위와 같은 레코드를 가진 테이블에 다음 3개의 INSERT 문장을 실행할 때 인서트 인텍션 락이 어떻게 사용되는지 살펴보겠습니다.

<br>

```sql
-- // 트랜잭션 -1 : 
BEGIN;
INSERT INTO tb_test VALUES (5);


-- // 트랜잭션 -2 : 
BEGIN:
INSERT INTO tb_test VALUES (3);

-- // 트랜잭션 -3 :
INSERT INTO tb_test VALUES (4);
```

tb_test 테이블에 4개의 레코드가 존재하는 상태에서 새로운 키 값 3, 4, 5를 각각 다른 트랜잭션에서 INSERT를 실행한다고 가정해보겠습니다. 

<br>

### `인서트 인텍션 락이 없다면`

InnoDB는 프라이머리 키 값 1부터 6 사이에 새로운 프라이머리 키 값을 INSERT 하기 위해 간격을 잠가야 하며, 이 때 베타적 갭 락을 사용할 것입니다.
즉, 순차적으로 실행 될 것입니다.

<br> 

### `인서트 인텍션 락이 있다면`

3개의 트랜잭션이 모두 1부터 6사이의 간격에 대한 인서트 인텍션 락을 동시에 획득하게 됩니다. 서로 충돌하는 값을 INSERT 하지 않는 이상, 동일 간격에 대해 서로 간섭을 받지 않고 동시에 INSERT 처리될 수 있습니다.

<설명 이하 생략>

<br>

## `INSERT INTO ... ON DUPLICATE KEY UPDATE`

INSERT 하려는 레코드에 대해 중복된 키 값이 이미 있는지 판단하기 위해 공유 잠금을 걸어야 합니다. 레코드가 존재한다면 베타적 잠검을 걸고 업데이트를 수행하며, 레코드가 존재하지 않는다면 일반적인 INSERT 문장과 같이 인서트 인텍션 락을 걸고 INSERT를 실행합니다. 


<br>

```
- 베타적 잠금이 뭔가 계속 했는데 쓰기 잠금이라고 한다...
- 공유 잠금은 뭔가 했는데 읽기 잠금이라고 한다...
```


<br>

