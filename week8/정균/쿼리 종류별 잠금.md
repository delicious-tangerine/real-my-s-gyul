# InnoDB의 기본 잠금 방식

## `SELECT`

REPEATABLE-READ 이하의 트랜잭션 격리 수준에서 InnoDB 테이블에 대한 SELECT 쿼리는 기본적으로 아무런 잠금을 사용하지 않습니다.
더 높은 격리 수준인 SERIALIZABLE 격리 수준에서는 모든 SELECT 쿼리에 자동적으로 `LOCK IN SHARE MODE`가 덧붙여져서 실행되는 효과를 내기 때문에 이 격리 수준에서 모든 SELECT 쿼리는 읽기 잠금을 걸고 레코드를 읽습니다. 
그래서 SERIALIZABLE 격리 수준에서는 MySQL 서버의 처리 성능이 떨어지게 됩니다. 하지만 일반적으로 MySQL에서는 `REPEATABLE-READ`, `READ-COMMITTED` 격리 수준을 사용하므로 SERIALIZABLE 격리 수준의 성능 저하는 크게 걱정하지 않아도 됩니다. 

<br> <br>

## `INSERT, UPDATE, DELETE`

INSERT, UPDATE, DELETE 쿼리는 모두 기본적으로 쓰기 잠금을 사용하며, 필요 시에는 읽기 잠금을 사용할 수 있습니다. `InnoDB`에서 UPDATE와 DELETE 문장을 실행할 때 SQL 문장이 조건에 일치하는 레코드를 찾기 위해 참조하는 인덱스의 모든 레코드에 잠금을 겁니다.
여기서 참조한 레코드에 잠금을 걸었다는 사실은 실제로 해당 쿼리 문장의 WHERE 조건에 일치하지 않는 레코드도 잠금의 대상이 될 수 있음을 의미합니다.

InnoDB가 레코드를 잠그는 방식을 예제로 한번 살펴보겠습니다. 

```sql
UPDATE employees
SET last_name='...'
WHERE first_name='Georgi' AND gender='F'
```

위의 UPDATE 문장은 employees 테이블에서 first_name이 `Geoigi`이면서 성별이 여자인 사원만 last_name을 변경하는 쿼리입니다. 
하지만 조건은 first_name과 gender를 동시에 포함하는 인덱스는 없고, first_name 컬럼만 가진 인덱스만 있습니다. 

예제의 UPDATE 문장은 어떤 레코드를 잠그고 어떤 레코드를 변경할까요? InnoDB 스토리지 엔진에서는 first_name이 `Georgi`인 모든 레코드를 잠그지만 최종적으로는 first_name이 `Georigi`이면서 성별이 'F'인 사원의 last_name만 변경하게 됩니다. 

<img width="1169" alt="스크린샷 2021-08-09 오전 12 59 59" src="https://user-images.githubusercontent.com/45676906/128638114-7d1f6018-df3a-4525-86a2-9564cfbeb7bf.png">

이는 MySQL에서 UPDATE나 DELETE 문장이 실행될 때 어떤 인덱스를 사용하는지에 따라 얼마나 큰 차이가 발생할 수 있는지 보여줍니다. UPDATE나 DELETE 문장이 제대로 된 인덱스를 사용하지 못한다면 상당히 비효율적으로 실행될 뿐더러 쿼리의 동시성도 상당히 나빠질 것입니다.(주의! !)

InnoDB에서는 UPDATE가 될 때 인덱스를 기반으로 레코드를 잠급니다. 그런데 사용할 수 있는 인덱스가 없다면 어떻게 될까요? `InnoDB는 테이블 모든 레코드에 잠금을 걸고, 조건에 일치하는 일부 레코드만 last_name을 변경할 것입니다.` InnoDB 스토리지 엔진에서 인덱스는 빠른 검색이나 정렬 등의 목적으로도 사용되지만 InnoDB 내부적으로는 레코드 잠금의 기준으로도 사용된다는 것을 알 수 있습니다. 이것은 상당히 중요하니까 잘 알아두는 것이 좋습니다. 

<br> <br>

# SQL 문장별로 사용하는 잠금

## SELECT 쿼리의 잠금

```sql
SELECT ... FROM ...
```

InnoDB 테이블에서 기본 형태의 SELECT 쿼리는 별도의 잠금을 사용하지 않습니다. 만약 읽어야 할 레코드가 다른 트랜잭션에 의해 변경되거나 삭제되는 중이라면 InnoDB에서 관리하고 있는 데이터의 `언두 로그`를 이용해서 레코드를 읽습니다.

<br>

## INSERT 쿼리의 잠금

INSERT 문장은 기본적으로 `베타적 레코드 잠금`을 사용합니다. 만약 해당 테이블에 프라이머리 키나 유니크 키가 존재한다면 중복 체크를 위해 `공유 레코드 잠금`을 먼저 획득해야 합니다. 또한 MySQL의 INSERT 문장은 추가적으로 `인서트 인텐션 락(INSERT INTENTION LOCK)`이라는 잠금도 사용합니다. 

<br>

### 공유 잠금이란? 

```
공유 잠금이 설정되어 있는 동안 다른 트랜잭션이 데이터를 변경할 수 없다. 
레코드나 간격을 읽을 때 다른 트랜잭션이 변경하지 못하게 하는 용도의 잠금 즉, 읽기 전용 작업
```

<br>

### 베타적 잠금

```
다른 트랜잭션이 읽거나 수정할 수 없다. 즉, 해당 트랜잭션에서 그 레코드나 간격을 변경하기 위해 획득해야 하는 잠금 
```

정리하면 `베타적 잠금은 내가 쓰기를 하는 동안 남들이 쓰지 못하게 하는 것`이고, `공유 잠금은 내가 읽는 동안 남들이 내가 읽고 있는 데이터를 변경하거나 삭제하지 못하게 하는 장치`입니다.
 
<br> <br>

## `UPDATE, DELETE 쿼리의 잠금`

UPDATE, DELETE 문장 모두 WHERE 조건에 일치하는 레코드를 찾기 위해 참조한 모든 레코드에 `베타적 넥스트 키 락`을 걸게 됩니다. 단순 레코드만 잠그지 않고 간격까지 잠그는 것은 `팬턴 레코드` 발생을 막기 위한 것입니다. 
일반적으로 `넥스트 키 락(레코드와 레코드 간의 갭을 동시에 잠그는 락)`을 설정하는 이유는 이 처리가 수행되는 동안 다른 트랜잭션에 의해 처리 범위의 레코드가 영향을 받지 않게 하기 위해서입니다.