# `InnoDB에서 데드락 만들기`

InnoDB는 다른 DBMS와 달리 레코드 간의 간격을 잠그는 갭 락이나 넥스트 키 락이 있습니다. 이로 인해 InnoDB의 잠금은 순수한 레코드 레벨의 잠금만 사용하는 DBMS보다는 잠금의 범위가 넓은 편입며, 그 영향으로 `데드락`도 자주 발생하는 편입니다.

InnoDB에서 대부분의 데드락은 공유 잠금을 가진 상태에서 다시 베타적 잠금을 얻으려고 하는 잠금 업그레이드 상황에서 자주 발생합니다. 또한 프로그램에서 하나의 기능이 동시에 병렬로 실행되면서 서로 간섭을 일으키는 경우도 많습니다.

<br>

## `패턴1(상호 거래 관련)`

A 사용자가 B 사용자에게 10 포인트를 전달하고, 그와 동시에 B 사용자도 A 사용자에게 10 포인트를 전달하는 시나리오를 생각해보겠습니다.

<img width="541" alt="스크린샷 2021-08-06 오후 12 56 28" src="https://user-images.githubusercontent.com/45676906/128453801-4c02b34a-0716-4569-b5d7-e30e6ba963c3.png">

트랜잭션 1번에서는 user_id='A'에 대해 베타적 잠금을 가지고 있고, 동시에 트랜잭션 2번은 user_id='B'에 대해 베타적 잠금을 가지고 있습니다.
이 상태에서 다시 각자 상대방 트랜잭션에서 가지고 있는 레코드를 변경하기 위해 베타적 잠금을 요청하면 데드락이 발생합니다.

<br>

## 패턴2(유니크 인덱스 관련)

이번에 살펴볼 데드락은 공유 잠금과 베타적 잠금이 혼합된 형태입니다. 이 패턴의 데드락은 테이블에 프라이머리 키 또는 유니크 키가 존재할 때 발생할 수 있는 데드락입니다.

<img width="537" alt="스크린샷 2021-08-06 오후 1 02 14" src="https://user-images.githubusercontent.com/45676906/128454179-f18db216-870f-474b-90f2-8d84d302e141.png">

위의 시나리오에서는 트랜잭션 1번이 ROLLBACK을 실행하기 바로 직전까지는 프라이머리 키가 9인 레코드에 대한 베타적 잠금은 트랜잭션 1번이 가지고 있고, 트랜잭션 2번과 3번은 공유 레코드 잠금을 획득하기 위해 대기하고 있는 상태입니다.
이 상태에서 트랜잭션 1번에서 ROLLBACK을 실행하면 프라이머리 키가 9인 레코드가 업어짐과 동시에 트랜잭션 1번이 걸었던 베타적 잠금이 해제됩니다. 이 때 트랜잭션 2번과 3번은 동시에 가상의 레코드에 대해 공유 잠금을 획득하고, 프라이머리 키가 9인 레코드가 없다는 사실을 알게 됩니다.

그래서 트랜잭션 2번과 3번은 새로운 레코드를 INSERT 하기 위해 베타적 잠금을 걸려고 할 것입니다. 이 때 트랜잭션 2번과 3번 중에서 어느 트랜잭션이 먼저 베타적 잠금을 요청하느냐에 관계없이 둘 중 아무도 배타적 잠금을 걸지 못합니다. 이미 트랜잭션 2번과 3번이 각자 공유 잠금을 가지고 있기 때문에 서로의 공유 잠금으로 인해 베타적 잠금을 걸지 못하고 서로 대기하게 됩니다. 이 상황이 데드락 상황인 것입니다.

<br>
