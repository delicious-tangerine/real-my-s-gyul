# `17.1.1 운영체제의 유틸리티를 이용해 장비의 부하 확인`

## `시스템의 전체적인 부하 확인`

유닉스 계역의 운영체제에서는 uptime 명령으로 해당 서버의 CPU가 처리해야 하는 작업이 얼마나 쌓여있는지 확인할 수 있다.

```
shell> uptime
```

<br> <br>

## `메모리 사용률`

```
shell> free -m -t
```

운영체제가 사용하는 물리적 메모리가 스왑 영역의 상태를 확인하려면 free 유틸리티를 사용하면 된다. 

<br> <br>

## `디스크 사용량`

```
shell> iostat -dx 1
```

iostat 명령은 장착된 디스크가 얼마나 사용되고 있는지 보여 줍니다.

<br> <br>

## `17.1.2 MySQL 서버의 에러 로그 확인`

MySQL 서버에서 특별히 이상 징후에 에러가 발생하면 기본적으로 에러 로그에 기록하게 되어 있다. 그래서 긴급한 상황일수록 에러 로그의 마지막 부분은 반드시 확인해 보는 것이 좋다. MySQL 에러 로그 파일은 별도로 파일명을 지정하지 않으면 MySQL 서버의 데이터 디렉터리에 `호스트명.err` 파일로 기록된다. 에러 로그가 너무 크다면 유닉스의 `less` 명령을 이용해 파일의 마지막 부분만 열어 보는 것이 가능하다.

```
shell> less +G mysqld.err
```

<br> <br>

## `17.1.3 MySQL 서버의 프로세스 리스트 확인`

로그 파일을 확인했는데, 특별한 문제가 없다면 MySQL 서버에 로그인해서 상태를 확인한다. MySQL 서버가 어떤 쿼리를 실행하고 있는지, 어떤 프로세스가 특히 오랜 시간 동안 실행하고 있는지 확인하는 것이 좋다.

```
show processlist
```

- 현재 MySQL 서버에 존재하는 전체 프로세스 목록
- 각 프로세스가 어떤 작업을 실행하고 있는지
- 각 작업의 현재 상태
- 각 작업의 실행 시간

<br> <br>

## `17.1.4 MySQL 서버의 최대 커넥션 설정 확인`

MySQL 서버에서 허용하는 최대 커넥션의 수를 터무니없이 크게 설정해 뒀다면 MySQL 서버는 동시에 너무 많은 요청을 받아 제대로 처리하지 못하는 현상이 발생할 수 있다. 이럴 때는 최대 허용 커넥션의 수를 적절히 줄여서 가능한 범위 내에서 MySQL 서버가 최대한 요청을 처리할 수 있게 해주는 것이 좋다. 만약 초기 최대 허용 커넥션 수가 너무 낮게 설정돼 있어 서버의 처리 용량에 여유가 있다면 최대 커넥션 수를 조금 더 늘려서 설정해주는 것이 좋다.

```
SHOW GLOBAL VARIABLES LIKE `max_connections`
```

<br> <br>

## `17.1.5 MySQL 서버의 슬로우 쿼리 분석`

MySQL 서버는 슬로우 쿼리 로그 설정을 통해 지정된 시간 이상 실행되는 느린 쿼리를 별도의 로그 파일로 기록할 수 있습니다. 이 로그 파일을 통해 어떤한 쿼리가 얼마나 느리게 실행됐는지 확인하고, 그 중에서 처리 시간이 오래 걸리거나 자주 실행된 빈도순으로 쿼리를 필터링할 수 있다. 

```
shell> mysqldumpslow -r -s c slow-query.log > parsed_slowquery.log
```

위의 명령은 `slow-query.log` 파일을 분석해서 실행된 횟수를 역순으로 정렬해서 그 결과를 parsed-slowquery.log 파일로 저장한다. 

<br> <br>

## `17.1.7 각 원인별 조치`

대부분의 MySQL 서버 과부하는 아래의 세 가지 중의 하나가 원인이다. 

### 튜닝되지 않은 쿼리

튜닝되지 않은 쿼리가 서버 과부하의 원인이라면 일반적으로는 서비스에서 사용되는 쿼리 중에서 상대적으로 부하가 더 높은 쪽에 속한 쿼리가 `SHOW PROCESSLIST` 항목에 많이 표시된다. 이럴 때는 `SHOW PROCESSLIST`에 많이 표시되는 쿼리를 집중적으로 찾아서 튜닝하면 된다. 

<br>

### 잘못 사용된 쿼리

잘못 사용된 쿼리란 애플리케이션의 버그나 사용자의 실수로 트랜잭션이 종료되지 않고 잠금이 계속 유지되면서 다른 서비스용 쿼리에 영향을 미치는 것을 의미한다. 주로 이런 상황에서는 `SHOW PROCESSLIST` 결과를 보면 특정 테이블에 대해 INSERT, UPDATE, DELETE 쿼리가 WAITING, UPDATING 로 표시될 때가 많다. 이럴 때는 잘못된 쿼리의 트랜잭션을 찾아서 종료해주면 된다. 

<br>

## `실제 사용자가 많은 경우`

쿼리는 적절히 튜닝됐지만 실제 사용자가 많아서 MySQL 서버가 과부하 상태로 된 것이라면 최대한 빨리 MySQL 서버를 더 투입해서 부하를 분산하는 것이 좋다. 

<br> <br>

## `17.3 MySQL 복구(데이터 파일 손상)`

### `17.3.2 InnoDB

InnoDB 테이블은 하드웨어나 운영체제의 문제가 아니라면 InnoDB 데이터 파일이나 로그 파일이 손상될 가능성은 상당히 낮은 편이다. 하지만 한번 문제가 생기면 복구하기가 쉽지 않다. InnoDB 데이터 파일은 기본적으로 MySQL 서버가 시작될 때 항상 자동 복구를 수행한다. 

<br> <br>

## `17.5 복제가 멈췄을 때`

복제가 구축된 MySQL 서버에서 쿼리나 시스템적인 오류로 인해 슬레이브의 복제가 진행되지 않고 멈추는 문제가 자주 발생할 수 있다. 슬레이브 MySQL 서버를 서비스용 애플리케이션에서 사용한다면 사용자에게 잘못된 결과를 보여 주게 되므로 큰 문제가 될 것이다. 

슬레이브 MySQL은 마스터 데이터와의 동기화를 위해 `SQL 스레드`, `IO 스레드`라는 2개의 스레드를 사용하는데, 이 두 스레드의 상태가 모두 정상일 때만 복제가 정상적으로 진행된다. 슬레이브 MySQL은 마스터 데이터와의 동기화를 위해 `SQL 스레드`, `IO 스레드`라는 2개의 스레드를 사용하는데, 이 두 스레드의 상태가 모두 정상일 때만 복제가 정상적으로 진행된다. 

<br>

### IO 스레드가 멈췄을 때

IO 스레드는 마스터 MySQL로부터 바이너리 로그를 가져오는 일을 담당하는 스레드다. 이 스레드의 상태가 `NO`일 때는 슬레이브 MySQL이 마스터 MySQL 서버에 접속하지 못하거나 로그인을 못하고 있음을 의마한다. 

<br>

### `SQL 스레드가 멈추었을 때`

SQL 스레드는 IO 스레드가 가져온 바이너리 로그를 슬레이브 MySQL 서버에서 재실행하는 역할을 수행한다. 이 때 재실행하는 쿼리 중에서 오류가 발생한다면 SQL 스레드는 더는 진행하지 않고 멈춰 있게 된다. 